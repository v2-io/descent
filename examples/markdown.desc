; Markdown parser - recursive descent for CommonMark subset
;
; Demonstrates:
; - Multiple BRACKET types for document structure
; - CONTENT types for text accumulation with SCAN optimization
; - Recursive calls for nested structures (blockquotes, lists, emphasis)
; - Column-based indentation tracking for list nesting
; - PREV-based flanking detection for emphasis
; - Character dispatch for block-level element detection
;
; Supported elements:
; - ATX headings (# through ######)
; - Paragraphs (blank line separated)
; - Fenced code blocks (```)
; - Blockquotes (> with nesting)
; - Unordered lists (- or *, nested via indentation)
; - Horizontal rules (---, ***)
; - Inline: code spans (`), emphasis (*), strong (**)

|parser markdown

; Block containers - emit Start on entry, End on return
|type[Heading]    BRACKET
|type[Paragraph]  BRACKET
|type[CodeBlock]  BRACKET
|type[Blockquote] BRACKET
|type[ListItem]   BRACKET
|type[ThematicBreak] BRACKET

; Inline containers - nesting handled via recursion
|type[Emphasis]   BRACKET
|type[Strong]     BRACKET

; Content - MARK on entry, emit on return
|type[Text]       CONTENT
|type[Code]       CONTENT

|entry-point /document

; ============================================================
; Document: dispatch to block handlers based on first character
; ============================================================

|function[document]
  |state[:main]
    |c[\n]      |.blank     | ->               |>>
    |c[ \t]     |.ws        | ->               |>> :indented
    |c[#]       |.hash      | /heading         |>>
    |c[`]       |.tick      | /maybe_fence     |>>
    |c[>]       |.quote     | -> | /blockquote |>>
    |c[-]       |.dash      | /dash_line       |>>
    |c[*]       |.star      | /star_line       |>>
    |default    |.para      | /paragraph       |>>

  ; After leading whitespace - check for list continuation
  |state[:indented]
    |c[ \t]     |.more_ws   | ->               |>>
    |c[-]       |.list      | -> | /list_item(COL) |>>
    |c[*]       |.list      | -> | /list_item(COL) |>>
    |c[\n]      |.blank     | ->               |>> :main
    |default    |.text      | /paragraph       |>> :main

; ============================================================
; ATX Headings: # through ######
; HeadingMarker captures the hashes for level detection
; ============================================================

|function[heading:Heading]
  |state[:hashes]
    |c[#]       |.hash      | ->               |>>
    |c[ \t]     |.space     | ->               |>> :content
    |c[\n]      |.empty     | ->               |return
    |default    |.not_head  | /paragraph       |return

  |state[:content]
    |c[ \t]     |.ws        | ->               |>>
    |c[\n]      |.eol       | ->               |return
    |default    |.text      | /inline          |>> :trailing

  ; Handle optional closing hashes: ## Heading ##
  |state[:trailing]
    |c[\n]      |.eol       | ->               |return
    |c[#]       |.trail     | ->               |>> :close_hash
    |default    |.more      | /inline          |>>

  |state[:close_hash]
    |c[#]       |.hash      | ->               |>>
    |c[ \t]     |.ws        | ->               |>>
    |c[\n]      |.eol       | ->               |return
    |default    |.text      | /inline          |>> :trailing

; ============================================================
; Paragraphs: continuous text until blank line or block marker
; ============================================================

|function[paragraph:Paragraph]
  |state[:main]
    |c[\n]      |.eol       | ->               |>> :check
    |default    |.text      | /inline          |>>

  ; Blank line or new block ends paragraph
  |state[:check]
    |c[\n]      |.blank     |return
    |c[#]       |.heading   |return
    |c[`]       |.fence     |return
    |c[>]       |.quote     |return
    |c[-]       |.dash      |return
    |c[*]       |.star      |return
    |default    |.cont      | /inline          |>> :main

; ============================================================
; Fenced code blocks: ``` ... ```
; ============================================================

|function[maybe_fence]
  |state[:check1]
    |c[`]       |.tick2     | ->               |>> :check2
    |default    |.not_fence | /paragraph       |return

  |state[:check2]
    |c[`]       |.tick3     | -> | /code_block |return
    |default    |.not_fence | /paragraph       |return

|function[code_block:CodeBlock]
  ; Skip optional info string (language hint)
  |state[:info]
    |c[\n]      |.eol       | ->               |>> :content
    |default    |.skip      | ->               |>>

  |state[:content]
    |c[`]       |.maybe_end | ->               |>> :end1
    |c[\n]      |.newline   | ->               |>>
    |default    |.code      | /code_line       |>>

  |state[:end1]
    |c[`]       |.tick2     | ->               |>> :end2
    |c[\n]      |.newline   | ->               |>> :content
    |default    |.not_end   | /code_line       |>> :content

  |state[:end2]
    |c[`]       |.tick3     | ->               |>> :end3
    |c[\n]      |.newline   | ->               |>> :content
    |default    |.not_end   | /code_line       |>> :content

  |state[:end3]
    |c[`]       |.extra     | ->               |>>
    |c[\n]      |.done      | ->               |return
    |c[ \t]     |.ws        | ->               |>>
    |default    |.not_end   |                  |>> :content

; Single line of code content
|function[code_line:Code]
  |state[:main]
    |c[\n]      |.eol       | ->               |return
    |default    |.char      | ->               |>>

; ============================================================
; Blockquotes: > prefixed, supports nesting
; ============================================================

|function[blockquote:Blockquote]
  |state[:start]
    |c[ ]       |.space     | ->               |>> :content
    |c[>]       |.nested    | -> | /blockquote |>> :after
    |c[\n]      |.empty     | ->               |>> :next
    |default    |.text      |                  |>> :content

  |state[:content]
    |c[\n]      |.eol       | ->               |>> :next
    |default    |.text      | /inline          |>>

  |state[:after]
    |c[\n]      |.eol       | ->               |>> :next
    |default    |.more      | /inline          |>> :after

  ; Check for continuation or end
  |state[:next]
    |c[>]       |.cont      | ->               |>> :start
    |c[\n]      |.blank     |return
    |c[ \t]     |.ws        | ->               |>> :lazy
    |default    |.end       |return

  ; Lazy continuation (no > but still in blockquote)
  |state[:lazy]
    |c[>]       |.quote     | ->               |>> :start
    |c[\n]      |.blank     |return
    |default    |.cont      |                  |>> :content

; ============================================================
; Lines starting with dash: list item or thematic break
; ============================================================

|function[dash_line]
  |state[:first]
    |c[-]       |.dash2     | ->               |>> :second
    |c[ \t]     |.space     | -> | /list_item(0) |return
    |c[\n]      |.eol       | -> | /list_item(0) |return
    |default    |.text      | /paragraph       |return

  |state[:second]
    |c[-]       |.dash3     | ->               |>> :hr_check
    |c[ \t]     |.space     | /paragraph       |return
    |default    |.text      | /paragraph       |return

  |state[:hr_check]
    |c[-]       |.more      | ->               |>>
    |c[ \t]     |.ws        | ->               |>>
    |c[\n]      |.hr        | -> | /thematic_break |return
    |default    |.text      | /paragraph       |return

; Lines starting with star: list item or thematic break
|function[star_line]
  |state[:first]
    |c[*]       |.star2     | ->               |>> :second
    |c[ \t]     |.space     | -> | /list_item(0) |return
    |c[\n]      |.eol       | -> | /list_item(0) |return
    |default    |.text      | /paragraph       |return

  |state[:second]
    |c[*]       |.star3     | ->               |>> :hr_check
    |c[ \t]     |.space     | /paragraph       |return
    |default    |.text      | /paragraph       |return

  |state[:hr_check]
    |c[*]       |.more      | ->               |>>
    |c[ \t]     |.ws        | ->               |>>
    |c[\n]      |.hr        | -> | /thematic_break |return
    |default    |.text      | /paragraph       |return

; Thematic break (horizontal rule) - just marks position
|function[thematic_break:ThematicBreak]
  |state[:main]
    |default    |.done      |return

; ============================================================
; List items: - or * prefixed, nesting via column tracking
; ============================================================

|function[list_item:ListItem] :col
  |state[:content]
    |c[\n]      |.eol       | ->               |>> :next
    |default    |.text      | /inline          |>>

  ; Check what follows: continuation, sibling, nested, or end
  |state[:next]
    |c[\n]      |.blank     | ->               |>> :after_blank
    |c[ \t]     |.ws        | ->               |>> :check_indent
    |c[-]       |.sibling   |return
    |c[*]       |.sibling   |return
    |default    |.dedent    |return

  ; After blank line - tight vs loose list detection point
  |state[:after_blank]
    |c[\n]      |.more_blank|return
    |c[ \t]     |.ws        | ->               |>> :check_indent
    |default    |.end       |return

  ; Check indentation for nesting
  |state[:check_indent]
    |c[ \t]     |.ws        | ->               |>>
    |if[COL <= col]         |return
    |c[-]       |.nested    | -> | /list_item(COL) |>> :next
    |c[*]       |.nested    | -> | /list_item(COL) |>> :next
    |c[\n]      |.blank     | ->               |>> :after_blank
    |default    |.cont      |                  |>> :content

; ============================================================
; Inline content: text, code spans, emphasis, strong
;
; Emphasis uses recursive descent with PREV for flanking rules:
; - Left-flanking * (followed by non-space): can open emphasis
; - Right-flanking * (PREV is non-space): can close emphasis
; - Nesting is natural: *a **b** c* = Emphasis(a Strong(b) c)
; ============================================================

|function[inline]
  |state[:main]
    |c[`]       |.code      | -> | /code_span   |>>
    |c[*]       |.star      | -> |>> :after_star
    |c[\n]      |.eol       |return
    |default    |.text      | /text            |>>

  ; Consumed one *, check for ** or left-flanking single *
  |state[:after_star]
    |c[*]       |.double    | -> |>> :after_two_stars
    |c[ \t\n]   |.not_left  | /literal_star    |>> :main    ; * + space = literal
    |default    |.emph      | /emphasis        |>> :main    ; left-flanking, open emphasis

  ; Consumed **, check if left-flanking
  |state[:after_two_stars]
    |c[ \t\n]   |.not_left  | /literal_two_stars |>> :main  ; ** + space = literal
    |default    |.strong    | /strong          |>> :main    ; left-flanking, open strong

; Inline code span: `code`
|function[code_span:Code]
  |state[:main]
    |c[`]       |.end       | ->               |return
    |c[\n]      |.eol       |return
    |default    |.char      | ->               |>>

; ============================================================
; Emphasis: *content* with recursive nesting
;
; Entered after consuming opening *, looking for right-flanking closer.
; Uses PREV to check if * is right-flanking (preceded by non-space).
; Nested emphasis/strong handled via recursive calls.
; ============================================================

|function[emphasis:Emphasis]
  |state[:content]
    |c[`]       |.code      | -> | /code_span   |>>
    |c[*]       |.star      |>> :check_star
    |c[\n]      |.eol       | ->               |return    ; unclosed at EOL
    |default    |.text      | /emph_text       |>>

  ; At *, check if it's a closer (right-flanking) or nested opener
  |state[:check_star]
    |if[PREV == ' ']        | -> |>> :not_right_flanking
    |if[PREV == '\t']       | -> |>> :not_right_flanking
    |if[PREV == '\n']       | -> |>> :not_right_flanking
    |if[PREV == 0]          | -> |>> :not_right_flanking
    ; PREV is non-space: right-flanking, this * can close
    |c[*]       |.double    | -> |>> :right_flank_double
    |default    |.close     | -> |return          ; single * closer, consume and return

  ; ** where first * is right-flanking - could be nested strong closing
  ; In single emphasis, treat first * as our closer, leave second for parent
  |state[:right_flank_double]
    |default    |.close     |return              ; close emphasis, don't consume second *

  ; * not right-flanking, consumed it, check if left-flanking (nested opener)
  |state[:not_right_flanking]
    |c[*]       |.double    | -> |>> :not_rf_double
    |c[ \t\n]   |.literal   | /literal_star_inner |>> :content   ; not left-flanking either
    |default    |.nested    | /emphasis          |>> :content   ; nested emphasis

  ; ** not right-flanking, check if left-flanking
  |state[:not_rf_double]
    |c[ \t\n]   |.literal   | /literal_two_stars_inner |>> :content
    |default    |.nested    | /strong            |>> :content   ; nested strong

; ============================================================
; Strong: **content** with recursive nesting
; ============================================================

|function[strong:Strong]
  |state[:content]
    |c[`]       |.code      | -> | /code_span   |>>
    |c[*]       |.star      |>> :check_star
    |c[\n]      |.eol       | ->               |return
    |default    |.text      | /emph_text       |>>

  ; At *, check for ** closer or nested emphasis
  |state[:check_star]
    |if[PREV == ' ']        | -> |>> :not_right_flanking
    |if[PREV == '\t']       | -> |>> :not_right_flanking
    |if[PREV == '\n']       | -> |>> :not_right_flanking
    |if[PREV == 0]          | -> |>> :not_right_flanking
    ; Right-flanking
    |c[*]       |.double    | -> |>> :right_flank_double
    |default    |.single    | -> |>> :right_flank_single

  ; Single right-flanking * inside ** - nested emphasis
  |state[:right_flank_single]
    |c[ \t\n]   |.literal   | /literal_star_inner |>> :content
    |default    |.nested    | /emphasis          |>> :content

  ; ** and right-flanking - this is our closer
  |state[:right_flank_double]
    |default    |.close     | -> |return

  ; * not right-flanking
  |state[:not_right_flanking]
    |c[*]       |.double    | -> |>> :not_rf_double
    |c[ \t\n]   |.literal   | /literal_star_inner |>> :content
    |default    |.nested    | /emphasis          |>> :content

  |state[:not_rf_double]
    |c[ \t\n]   |.literal   | /literal_two_stars_inner |>> :content
    |default    |.nested    | /strong            |>> :content

; ============================================================
; Text collection - stops at significant chars
; ============================================================

; Plain text in normal inline context
|function[text:Text]
  |state[:main]
    |c[`]       |.code      |return
    |c[*]       |.star      |return
    |c[\n]      |.eol       |return
    |default    |.char      | ->               |>>

; Text inside emphasis/strong - same stops
|function[emph_text:Text]
  |state[:main]
    |c[`]       |.code      |return
    |c[*]       |.star      |return
    |c[\n]      |.eol       |return
    |default    |.char      | ->               |>>

; ============================================================
; Literal star handling
;
; When * or ** is neither opener nor closer, emit as text.
; These are called after consuming the star(s), so we use
; explicit content in the emit.
; ============================================================

; For now, these emit empty - the star handling needs rethinking
; TODO: Add emit(Type, "literal") support or restructure

|function[literal_star:Text]
  |state[:main]
    |default    |.skip      |return

|function[literal_two_stars:Text]
  |state[:main]
    |default    |.skip      |return

|function[literal_star_inner:Text]
  |state[:main]
    |default    |.skip      |return

|function[literal_two_stars_inner:Text]
  |state[:main]
    |default    |.skip      |return
