; Markdown parser - recursive descent for CommonMark subset
;
; Demonstrates:
; - Multiple BRACKET types for document structure
; - CONTENT types for text accumulation with SCAN optimization
; - Recursive calls for nested structures (blockquotes, lists, emphasis)
; - Column-based indentation tracking for list nesting
; - PREV-based flanking detection for emphasis
; - Character dispatch for block-level element detection
;
; Supported elements:
; - ATX headings (# through ######)
; - Paragraphs (blank line separated)
; - Fenced code blocks (```)
; - Blockquotes (> with nesting)
; - Unordered lists (- or *, nested via indentation)
; - Horizontal rules (---, ***)
; - Inline: code spans (`), emphasis (*/_), strong (**/__), strikethrough (~~)

|parser markdown

; Block containers - emit Start on entry, End on return
|type[Heading]    BRACKET
|type[Paragraph]  BRACKET
|type[CodeBlock]  BRACKET
|type[Blockquote] BRACKET
|type[ListItem]   BRACKET
|type[ThematicBreak] BRACKET

; Inline containers - nesting handled via recursion
|type[Emphasis]     BRACKET
|type[Strong]       BRACKET
|type[Strikethrough] BRACKET

; Content - MARK on entry, emit on return
|type[Text]       CONTENT
|type[Code]       CONTENT

|entry-point /document

; ============================================================
; Document: dispatch to block handlers based on first character
; ============================================================

|function[document]
  |state[:main]
    |c['\n']      |.blank     | ->               |>>
    |c[' \t']     |.ws        | ->               |>> :indented
    |c['#']       |.hash      | /heading         |>>
    |c['`']       |.tick      | /maybe_fence     |>>
    |c['>']       |.quote     | -> | /blockquote |>>
    |c[-]       |.dash      | -> | /dash_line       |>>
    ; Note: * at line start goes to paragraph - list detection in :indented only
    ; This allows *emphasis* at start of paragraph
    |default    |.para      | /paragraph       |>>

  ; After leading whitespace - check for list continuation
  |state[:indented]
    |c[' \t']     |.more_ws   | ->               |>>
    |c[-]       |.list      | -> | /list_item(COL) |>>
    |c['*']       |.list      | -> | /list_item(COL) |>>
    |c['\n']      |.blank     | ->               |>> :main
    |default    |.text      | /paragraph       |>> :main

; ============================================================
; ATX Headings: # through ######
; HeadingMarker captures the hashes for level detection
; ============================================================

|function[heading:Heading]
  |state[:hashes]
    |c['#']       |.hash      | ->               |>>
    |c[' \t']     |.space     | ->               |>> :content
    |c['\n']      |.empty     | ->               |return
    |default    |.not_head  | /paragraph       |return

  |state[:content]
    |c[' \t']     |.ws        | ->               |>>
    |c['\n']      |.eol       | ->               |return
    |default    |.text      | /inline          |>> :trailing

  ; Handle optional closing hashes: ## Heading ##
  |state[:trailing]
    |c['\n']      |.eol       | ->               |return
    |c['#']       |.trail     | ->               |>> :close_hash
    |default    |.more      | /inline          |>>

  |state[:close_hash]
    |c['#']       |.hash      | ->               |>>
    |c[' \t']     |.ws        | ->               |>>
    |c['\n']      |.eol       | ->               |return
    |default    |.text      | /inline          |>> :trailing

; ============================================================
; Paragraphs: continuous text until blank line or block marker
; ============================================================

|function[paragraph:Paragraph]
  |state[:main]
    |c['\n']      |.eol       | ->               |>> :check
    |default    |.text      | /inline          |>>

  ; Blank line or new block ends paragraph
  |state[:check]
    |c['\n']      |.blank     |return
    |c['#']       |.heading   |return
    |c['`']       |.fence     |return
    |c['>']       |.quote     |return
    |c[-]       |.dash      |return
    |c['*']       |.star      |return
    |default    |.cont      | /inline          |>> :main

; ============================================================
; Fenced code blocks: ``` ... ```
; ============================================================

|function[maybe_fence]
  |state[:check1]
    |c['`']       |.tick2     | ->               |>> :check2
    |default    |.not_fence | /paragraph       |return

  |state[:check2]
    |c['`']       |.tick3     | -> | /code_block |return
    |default    |.not_fence | /paragraph       |return

|function[code_block:CodeBlock]
  ; Skip optional info string (language hint)
  |state[:info]
    |c['\n']      |.eol       | ->               |>> :content
    |default    |.skip      | ->               |>>

  |state[:content]
    |c['`']       |.maybe_end | ->               |>> :end1
    |c['\n']      |.newline   | ->               |>>
    |default    |.code      | /code_line       |>>

  |state[:end1]
    |c['`']       |.tick2     | ->               |>> :end2
    |c['\n']      |.newline   | ->               |>> :content
    |default    |.not_end   | /code_line       |>> :content

  |state[:end2]
    |c['`']       |.tick3     | ->               |>> :end3
    |c['\n']      |.newline   | ->               |>> :content
    |default    |.not_end   | /code_line       |>> :content

  |state[:end3]
    |c['`']       |.extra     | ->               |>>
    |c['\n']      |.done      | ->               |return
    |c[' \t']     |.ws        | ->               |>>
    |default    |.not_end   |                  |>> :content

; Single line of code content
|function[code_line:Code]
  |state[:main]
    |c['\n']      |.eol       | ->               |return
    |default    |.char      | ->               |>>

; ============================================================
; Blockquotes: > prefixed, supports nesting
; ============================================================

|function[blockquote:Blockquote]
  |state[:start]
    |c[' ']       |.space     | ->               |>> :content
    |c['>']       |.nested    | -> | /blockquote |>> :after
    |c['\n']      |.empty     | ->               |>> :next
    |default    |.text      |                  |>> :content

  |state[:content]
    |c['\n']      |.eol       | ->               |>> :next
    |default    |.text      | /inline          |>>

  |state[:after]
    |c['\n']      |.eol       | ->               |>> :next
    |default    |.more      | /inline          |>> :after

  ; Check for continuation or end
  |state[:next]
    |c['>']       |.cont      | ->               |>> :start
    |c['\n']      |.blank     |return
    |c[' \t']     |.ws        | ->               |>> :lazy
    |default    |.end       |return

  ; Lazy continuation (no > but still in blockquote)
  |state[:lazy]
    |c['>']       |.quote     | ->               |>> :start
    |c['\n']      |.blank     |return
    |default    |.cont      |                  |>> :content

; ============================================================
; Lines starting with dash: list item or thematic break
; ============================================================

|function[dash_line]
  |state[:first]
    |c[-]       |.dash2     | ->               |>> :second
    |c[' \t']     |.space     | -> | /list_item(0) |return
    |c['\n']      |.eol       | -> | /list_item(0) |return
    |default    |.text      | /paragraph       |return

  |state[:second]
    |c[-]       |.dash3     | ->               |>> :hr_check
    |c[' \t']     |.space     | /paragraph       |return
    |default    |.text      | /paragraph       |return

  |state[:hr_check]
    |c[-]       |.more      | ->               |>>
    |c[' \t']     |.ws        | ->               |>>
    |c['\n']      |.hr        | -> | /thematic_break |return
    |default    |.text      | /paragraph       |return

; Lines starting with star: list item or thematic break
; Key: "* " (star space) = list, "*x" (star non-space) = paragraph with emphasis
|function[star_line]
  |state[:first]
    |c['*']       |.star2     | ->               |>> :second
    |default    |.text      | /paragraph       |return    ; bare * at start - shouldn't happen

  |state[:second]
    |c['*']       |.star3     | ->               |>> :hr_check
    |c[' \t']     |.space     | -> | /list_item(0) |return   ; "* " = list item
    |c['\n']      |.eol       | -> | /list_item(0) |return   ; "*\n" = empty list item
    |default    |.text      | PREPEND(*) | /paragraph |return   ; "*x" = emphasis, restore *

  |state[:hr_check]
    |c['*']       |.more      | ->               |>>
    |c[' \t']     |.ws        | ->               |>>
    |c['\n']      |.hr        | -> | /thematic_break |return
    |default    |.text      | PREPEND(**) | /paragraph |return  ; "**x" = strong, restore **

; Thematic break (horizontal rule) - just marks position
|function[thematic_break:ThematicBreak]
  |state[:main]
    |default    |.done      |return

; ============================================================
; List items: - or * prefixed, nesting via column tracking
; ============================================================

|function[list_item:ListItem] :col
  |state[:content]
    |c['\n']      |.eol       | ->               |>> :next
    |default    |.text      | /inline          |>>

  ; Check what follows: continuation, sibling, nested, or end
  |state[:next]
    |c['\n']      |.blank     | ->               |>> :after_blank
    |c[' \t']     |.ws        | ->               |>> :check_indent
    |c[-]       |.sibling   |return
    |c['*']       |.sibling   |return
    |default    |.dedent    |return

  ; After blank line - tight vs loose list detection point
  |state[:after_blank]
    |c['\n']      |.more_blank|return
    |c[' \t']     |.ws        | ->               |>> :check_indent
    |default    |.end       |return

  ; Check indentation for nesting
  |state[:check_indent]
    |c[' \t']     |.ws        | ->               |>>
    |if[COL <= col]         |return
    |c[-]       |.nested    | -> | /list_item(COL) |>> :next
    |c['*']       |.nested    | -> | /list_item(COL) |>> :next
    |c['\n']      |.blank     | ->               |>> :after_blank
    |default    |.cont      |                  |>> :content

; ============================================================
; Inline content: text, code spans, emphasis, strong
;
; Emphasis uses recursive descent with PREV for flanking rules:
; - Left-flanking * (followed by non-space): can open emphasis
; - Right-flanking * (PREV is non-space): can close emphasis
; - Nesting is natural: *a **b** c* = Emphasis(a Strong(b) c)
; ============================================================

|function[inline]
  |state[:main]
    |c['`']       |.code      | -> | /code_span   |>>
    |c['*']       |.star      | -> |>> :after_star
    |c[_]       |.under     | -> |>> :after_under
    |c['~']       |.tilde     | -> |>> :after_tilde
    |c['\n']      |.eol       |return
    |default    |.text      | /text            |>>

  ; Consumed one *, check for ** or left-flanking single *
  |state[:after_star]
    |c['*']       |.double    | -> |>> :after_two_stars
    |c[' \t\n']   |.not_left  | Text(*) |>> :main             ; * + space = literal
    |default    |.emph      | /emphasis        |>> :main    ; left-flanking, open emphasis

  ; Consumed **, check if left-flanking
  |state[:after_two_stars]
    |c[' \t\n']   |.not_left  | Text(**) |>> :main            ; ** + space = literal
    |default    |.strong    | /strong          |>> :main    ; left-flanking, open strong

  ; Consumed one _, check for __ or left-flanking single _
  |state[:after_under]
    |c[_]       |.double    | -> |>> :after_two_unders
    |c[' \t\n']   |.not_left  | Text(_) |>> :main             ; _ + space = literal
    |default    |.emph      | /emphasis_under  |>> :main    ; left-flanking, open emphasis

  ; Consumed __, check if left-flanking
  |state[:after_two_unders]
    |c[' \t\n']   |.not_left  | Text(__) |>> :main            ; __ + space = literal
    |default    |.strong    | /strong_under    |>> :main    ; left-flanking, open strong

  ; Consumed one ~, check for ~~
  |state[:after_tilde]
    |c['~']       |.double    | -> |>> :after_two_tildes
    |default    |.literal   | Text(~) |>> :main             ; single ~ = literal

  ; Consumed ~~, check if left-flanking
  |state[:after_two_tildes]
    |c[' \t\n']   |.not_left  | Text(~~) |>> :main            ; ~~ + space = literal
    |default    |.strike    | /strikethrough   |>> :main    ; left-flanking, open strikethrough

; Inline code span: `code`
; CONTENT type: auto-MARK on entry, emit on return
; Must TERM before consuming closing ` to exclude it from content
|function[code_span:Code]
  |state[:main]
    |c['`']       |.end       | TERM | ->        |return
    |c['\n']      |.eol       |return
    |default    |.char      | ->               |>>

; ============================================================
; Emphasis: *content* with recursive nesting
;
; Entered after consuming opening *, looking for right-flanking closer.
; Uses PREV to check if * is right-flanking (preceded by non-space).
; Nested emphasis/strong handled via recursive calls.
; ============================================================

|function[emphasis:Emphasis]
  |state[:content]
    |c['`']       |.code      | -> | /code_span   |>>
    |c['*']       |.star      |>> :check_star
    |c['\n']      |.eol       | ->               |return    ; unclosed at EOL
    |default    |.text      | /emph_text       |>>

  ; At *, check if it's a closer (right-flanking) or nested opener
  |state[:check_star]
    |if[PREV == ' ']        | -> |>> :not_right_flanking
    |if[PREV == '\t']       | -> |>> :not_right_flanking
    |if[PREV == '\n']       | -> |>> :not_right_flanking
    |if[PREV == 0]          | -> |>> :not_right_flanking
    ; PREV is non-space: right-flanking, this * can close
    |c['*']       |.double    | -> |>> :right_flank_double
    |default    |.close     | -> |return          ; single * closer, consume and return

  ; ** where first * is right-flanking - could be nested strong closing
  ; In single emphasis, treat first * as our closer, leave second for parent
  |state[:right_flank_double]
    |default    |.close     |return              ; close emphasis, don't consume second *

  ; * not right-flanking, consumed it, check if left-flanking (nested opener)
  |state[:not_right_flanking]
    |c['*']       |.double    | -> |>> :not_rf_double
    |c[' \t\n']   |.literal   | Text(*) |>> :content             ; literal *
    |default    |.nested    | /emphasis          |>> :content   ; nested emphasis

  ; ** not right-flanking, check if left-flanking
  |state[:not_rf_double]
    |c[' \t\n']   |.literal   | Text(**) |>> :content            ; literal **
    |default    |.nested    | /strong            |>> :content   ; nested strong

; ============================================================
; Strong: **content** with recursive nesting
; ============================================================

|function[strong:Strong]
  |state[:content]
    |c['`']       |.code      | -> | /code_span   |>>
    |c['*']       |.star      |>> :check_star
    |c['\n']      |.eol       | ->               |return
    |default    |.text      | /emph_text       |>>

  ; At *, check for ** closer or nested emphasis
  |state[:check_star]
    |if[PREV == ' ']        | -> |>> :not_right_flanking
    |if[PREV == '\t']       | -> |>> :not_right_flanking
    |if[PREV == '\n']       | -> |>> :not_right_flanking
    |if[PREV == 0]          | -> |>> :not_right_flanking
    ; Right-flanking
    |c['*']       |.double    | -> |>> :right_flank_double
    |default    |.single    | -> |>> :right_flank_single

  ; Single right-flanking * inside ** - nested emphasis
  |state[:right_flank_single]
    |c[' \t\n']   |.literal   | Text(*) |>> :content             ; literal *
    |default    |.nested    | /emphasis          |>> :content

  ; ** and right-flanking - this is our closer
  |state[:right_flank_double]
    |default    |.close     | -> |return

  ; * not right-flanking
  |state[:not_right_flanking]
    |c['*']       |.double    | -> |>> :not_rf_double
    |c[' \t\n']   |.literal   | Text(*) |>> :content             ; literal *
    |default    |.nested    | /emphasis          |>> :content

  |state[:not_rf_double]
    |c[' \t\n']   |.literal   | Text(**) |>> :content            ; literal **
    |default    |.nested    | /strong            |>> :content

; ============================================================
; Emphasis with underscore: _content_ with recursive nesting
; Same structure as * emphasis but uses _ delimiter
; ============================================================

|function[emphasis_under:Emphasis]
  |state[:content]
    |c['`']       |.code      | -> | /code_span   |>>
    |c[_]       |.under     |>> :check_under
    |c['\n']      |.eol       | ->               |return
    |default    |.text      | /emph_text_under |>>

  |state[:check_under]
    |if[PREV == ' ']        | -> |>> :not_right_flanking
    |if[PREV == '\t']       | -> |>> :not_right_flanking
    |if[PREV == '\n']       | -> |>> :not_right_flanking
    |if[PREV == 0]          | -> |>> :not_right_flanking
    |c[_]       |.double    | -> |>> :right_flank_double
    |default    |.close     | -> |return

  |state[:right_flank_double]
    |default    |.close     |return

  |state[:not_right_flanking]
    |c[_]       |.double    | -> |>> :not_rf_double
    |c[' \t\n']   |.literal   | Text(_) |>> :content
    |default    |.nested    | /emphasis_under    |>> :content

  |state[:not_rf_double]
    |c[' \t\n']   |.literal   | Text(__) |>> :content
    |default    |.nested    | /strong_under      |>> :content

; ============================================================
; Strong with underscore: __content__ with recursive nesting
; ============================================================

|function[strong_under:Strong]
  |state[:content]
    |c['`']       |.code      | -> | /code_span   |>>
    |c[_]       |.under     |>> :check_under
    |c['\n']      |.eol       | ->               |return
    |default    |.text      | /emph_text_under |>>

  |state[:check_under]
    |if[PREV == ' ']        | -> |>> :not_right_flanking
    |if[PREV == '\t']       | -> |>> :not_right_flanking
    |if[PREV == '\n']       | -> |>> :not_right_flanking
    |if[PREV == 0]          | -> |>> :not_right_flanking
    |c[_]       |.double    | -> |>> :right_flank_double
    |default    |.single    | -> |>> :right_flank_single

  |state[:right_flank_single]
    |c[' \t\n']   |.literal   | Text(_) |>> :content
    |default    |.nested    | /emphasis_under    |>> :content

  |state[:right_flank_double]
    |default    |.close     | -> |return

  |state[:not_right_flanking]
    |c[_]       |.double    | -> |>> :not_rf_double
    |c[' \t\n']   |.literal   | Text(_) |>> :content
    |default    |.nested    | /emphasis_under    |>> :content

  |state[:not_rf_double]
    |c[' \t\n']   |.literal   | Text(__) |>> :content
    |default    |.nested    | /strong_under      |>> :content

; ============================================================
; Strikethrough: ~~content~~ (GFM extension)
; ============================================================

|function[strikethrough:Strikethrough]
  |state[:content]
    |c['`']       |.code      | -> | /code_span   |>>
    |c['~']       |.tilde     |>> :check_tilde
    |c['\n']      |.eol       | ->               |return
    |default    |.text      | /strike_text     |>>

  |state[:check_tilde]
    |if[PREV == ' ']        | -> |>> :not_right_flanking
    |if[PREV == '\t']       | -> |>> :not_right_flanking
    |if[PREV == '\n']       | -> |>> :not_right_flanking
    |if[PREV == 0]          | -> |>> :not_right_flanking
    ; Right-flanking
    |c['~']       |.double    | -> |>> :right_flank_double
    |default    |.single    | Text(~) |>> :content           ; single ~ inside ~~ = literal

  |state[:right_flank_double]
    |default    |.close     | -> |return                     ; ~~ closes strikethrough

  |state[:not_right_flanking]
    ; ~ not right-flanking, check if left-flanking for nested strikethrough
    |c['~']       |.double    | -> |>> :not_rf_double
    |c[' \t\n']   |.literal   | Text(~) |>> :content
    |default    |.nested    | /strikethrough   |>> :content  ; nested strikethrough

  |state[:not_rf_double]
    |c[' \t\n']   |.literal   | Text(~~) |>> :content
    |default    |.nested    | /strikethrough   |>> :content

; ============================================================
; Text collection - stops at significant chars
; ============================================================

; Plain text in normal inline context
|function[text:Text]
  |state[:main]
    |c['`']       |.code      |return
    |c['*']       |.star      |return
    |c[_]       |.under     |return
    |c['~']       |.tilde     |return
    |c['\n']      |.eol       |return
    |default    |.char      | ->               |>>

; Text inside */emphasis/strong - stops at * delimiter
|function[emph_text:Text]
  |state[:main]
    |c['`']       |.code      |return
    |c['*']       |.star      |return
    |c['\n']      |.eol       |return
    |default    |.char      | ->               |>>

; Text inside _emphasis/strong - stops at _ delimiter
|function[emph_text_under:Text]
  |state[:main]
    |c['`']       |.code      |return
    |c[_]       |.under     |return
    |c['\n']      |.eol       |return
    |default    |.char      | ->               |>>

; Text inside ~~strikethrough~~ - stops at ~ delimiter
|function[strike_text:Text]
  |state[:main]
    |c['`']       |.code      |return
    |c['~']       |.tilde     |return
    |c['\n']      |.eol       |return
    |default    |.char      | ->               |>>

