# frozen_string_literal: true

module Descent
  # Generates Python code using the railroad-diagrams library.
  #
  # This is a SPIKE - quick proof-of-concept, not production quality.
  # The railroad-diagrams library is what JSON.org uses for its diagrams.
  #
  # Usage:
  #   pip install railroad-diagrams
  #   descent diagram parser.desc > diagram.py
  #   python diagram.py > diagram.svg
  #
  # Mapping from .desc concepts to railroad primitives:
  #   - Function → one Diagram per function
  #   - State cases → Choice (alternatives)
  #   - Self-looping state → ZeroOrMore or OneOrMore
  #   - c[...] match → Terminal (circles)
  #   - /function call → NonTerminal (rectangles)
  #   - |return → end of path
  #   - |>> → loop/continue
  class Railroad
    def initialize(ir) = @ir = ir

    def generate
      lines = []
      lines << header
      lines << ''

      @ir.functions.each do |func|
        lines << function_diagram(func)
        lines << ''
      end

      lines << footer
      lines.join("\n")
    end

    private

    def header
      <<~PY
        #!/usr/bin/env python3
        """
        Railroad diagrams for #{@ir.name} parser.
        Generated by descent - run this to produce SVG.

        Usage:
          python #{@ir.name}_diagram.py > #{@ir.name}_diagram.svg

        Or for individual function SVGs:
          python #{@ir.name}_diagram.py --split

        Requires: pip install railroad-diagrams
        """
        from railroad import Diagram, Choice, Sequence, Optional, ZeroOrMore, OneOrMore
        from railroad import Terminal, NonTerminal, Comment, Skip, Start, End
        import sys

        DIAGRAMS = {}
      PY
    end

    def footer
      <<~PY
        def main():
            import railroad
            if '--split' in sys.argv:
                # Output each function to separate file
                for name, diag in DIAGRAMS.items():
                    with open(f'{name}.svg', 'w') as f:
                        diag.writeStandalone(f.write)
                    print(f'Wrote {name}.svg', file=sys.stderr)
            else:
                # Output all diagrams as single HTML with proper CSS
                print('<!DOCTYPE html><html><head>')
                print(f'<style>{railroad.DEFAULT_STYLE}</style>')
                print('<style>svg { margin: 20px; display: block; } h2 { font-family: sans-serif; }</style>')
                print('</head><body>')
                for name, diag in DIAGRAMS.items():
                    print(f'<h2>{name}</h2>')
                    diag.writeSvg(print)
                print('</body></html>')

        if __name__ == '__main__':
            main()
      PY
    end

    def function_diagram(func)
      # Build the diagram for this function
      # Analyze state transitions to build proper railroad structure

      states = func.states
      return "# #{func.name}: no states" if states.empty?

      # Build a map of state names to states for lookup
      state_map = states.to_h { |s| [s.name, s] }

      # Start from the first state and build the diagram
      diagram_content = build_state_sequence(states.first, state_map, Set.new)

      # Add return type info as comment if present
      comment = func.return_type ? ", Comment('→ #{func.return_type}')" : ''

      <<~PY
        # Function: #{func.name}#{"(#{func.params.join(', ')})" unless func.params.empty?}
        DIAGRAMS['#{func.name}'] = Diagram(
            #{diagram_content}#{comment}
        )
      PY
    end

    def build_state_sequence(state, state_map, visited)
      return 'Skip()' if state.nil? || visited.include?(state.name)

      visited += [state.name]
      cases   = state.cases.reject(&:conditional?)
      return 'Skip()' if cases.empty?

      # Categorize cases by their transition type
      exit_cases    = []      # Cases that return (exit the function)
      loop_cases    = []      # Cases that self-loop (stay in this state)
      forward_cases = [] # Cases that go to another state

      cases.each do |kase|
        transition = find_transition(kase)
        # Normalize transition: remove leading colon if present
        transition = transition.sub(/^:/, '') if transition
        if returns?(kase)
          exit_cases << kase
        elsif transition.nil? || transition.empty? || transition == state.name
          loop_cases << kase
        else
          forward_cases << [kase, transition]
        end
      end

      parts = []

      # If we have forward transitions, they form a sequence
      # Group cases by their target state
      if forward_cases.any?
        # Cases that go to the same next state can be shown as Choice
        by_target = forward_cases.group_by { |_, target| target }

        by_target.each do |target_state, cases_to_target|
          entry_cases = cases_to_target.map(&:first)
          if entry_cases.size == 1
            parts << case_to_element(entry_cases.first, nil)
          else
            elements = entry_cases.map { |c| case_to_element(c, nil) }
            parts << "Choice(0, #{elements.join(', ')})"
          end

          # Recurse into the target state
          if state_map[target_state] && !visited.include?(target_state)
            next_part = build_state_sequence(state_map[target_state], state_map, visited)
            parts << next_part unless next_part == 'Skip()'
          end
        end
      end

      # Loop cases become ZeroOrMore
      if loop_cases.any?
        if loop_cases.size == 1
          loop_content = case_to_element(loop_cases.first, nil)
        else
          elements     = loop_cases.map { |c| case_to_element(c, nil) }
          loop_content = "Choice(0, #{elements.join(', ')})"
        end
        parts << "ZeroOrMore(#{loop_content})"
      end

      # Exit cases become the terminator
      if exit_cases.any?
        if exit_cases.size == 1
          parts << case_to_element(exit_cases.first, nil)
        else
          elements = exit_cases.map { |c| case_to_element(c, nil) }
          parts << "Choice(0, #{elements.join(', ')})"
        end
      end

      return 'Skip()' if parts.empty?
      return parts.first if parts.size == 1

      "Sequence(#{parts.join(', ')})"
    end

    def find_transition(kase)
      kase.commands.each do |cmd|
        return cmd.args[:value] || cmd.args['value'] if cmd.type == :transition
      end
      nil
    end

    def returns?(kase) = kase.commands.any? { |cmd| cmd.type == :return }

    # Known character class patterns - map expanded chars back to names
    CHAR_CLASS_NAMES = {
      'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' => 'LETTER',
      'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-' => 'LABEL_CONT',
      '0123456789' => 'DIGIT',
      '0123456789abcdefABCDEF' => 'HEX_DIGIT',
      " \t" => 'WS',
      'abcdefghijklmnopqrstuvwxyz' => 'a-z',
      'ABCDEFGHIJKLMNOPQRSTUVWXYZ' => 'A-Z'
    }.freeze

    def case_to_element(kase, _func)
      # Build element for a single case
      parts = []

      # What we're matching
      if kase.default?
        parts << 'Skip()' # Default case = any other char
      elsif kase.chars && !kase.chars.empty?
        # Character match - show as terminal
        chars_display = format_chars(kase.chars)
        parts << "Terminal(#{chars_display.inspect})"
      elsif kase.special_class
        # Special class like LETTER, DIGIT
        parts << "NonTerminal(#{kase.special_class.to_s.upcase.inspect})"
      elsif kase.param_ref
        # Parameter reference
        parts << "NonTerminal(':#{kase.param_ref}')"
      end

      # What actions we take - look for function calls
      kase.commands.each do |cmd|
        case cmd.type
        when :call
          func_name = cmd.args[:name]
          parts << "NonTerminal(#{func_name.inspect})"
        when :emit
          # Inline emit - show as comment
          event_type = cmd.args[:type]
          parts << "Comment(#{event_type.inspect})" if event_type
        when :keywords
          # Keywords lookup
          kw_name = cmd.args[:name]
          parts << "NonTerminal('KEYWORDS(#{kw_name})')"
        end
      end

      return parts.first if parts.size == 1

      "Sequence(#{parts.join(', ')})"
    end

    def format_chars(chars)
      if chars.size == 1
        escape_char(chars.first)
      else
        # Check if this matches a known class
        joined = chars.join
        CHAR_CLASS_NAMES[joined] || chars.map { |c| escape_char(c) }.join('')
      end
    end

    def escape_char(char)
      case char
      when "\n" then '\\n'
      when "\t" then '\\t'
      when "\r" then '\\r'
      when ' '  then '␣'
      else char
      end
    end
  end
end
