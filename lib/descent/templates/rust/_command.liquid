{% comment %}
  Command partial - generates Rust code for a single IR::Command

  Variables in scope:
  - cmd: the command hash {type, args}
  - func: the function hash
  - return_type_info: the function's return type info (or nil)
  - states: array of states (for multi-state functions)
{% endcomment %}

{% case cmd.type %}

{% when "advance" %}
                    self.advance();

{% when "advance_to" %}
{% comment %} Explicit advance-to: ->[chars] uses memchr to scan forward {% endcomment %}
{% assign target_chars = cmd.args.value | split: "" %}
{% assign char_count = target_chars | size %}
{% if char_count == 1 %}
                    self.scan_to1({{ target_chars[0] | escape_rust_char }});
{% elsif char_count == 2 %}
                    self.scan_to2({{ target_chars[0] | escape_rust_char }}, {{ target_chars[1] | escape_rust_char }});
{% elsif char_count == 3 %}
                    self.scan_to3({{ target_chars[0] | escape_rust_char }}, {{ target_chars[1] | escape_rust_char }}, {{ target_chars[2] | escape_rust_char }});
{% else %}
                    // advance_to with {{ char_count }} chars - use memchr iter
                    if let Some(idx) = memchr::memchr_iter({% for c in target_chars %}{{ c | escape_rust_char }}{% unless forloop.last %}, {% endunless %}{% endfor %}, &self.input[self.pos..]).next() {
                        for &b in &self.input[self.pos..self.pos + idx] {
                            if b == b'\n' { self.line += 1; self.column = 1; } else { self.column += 1; }
                        }
                        self.pos += idx;
                    } else {
                        for &b in &self.input[self.pos..] {
                            if b == b'\n' { self.line += 1; self.column = 1; } else { self.column += 1; }
                        }
                        self.pos = self.input.len();
                    }
{% endif %}

{% when "mark" %}
                    self.mark();

{% when "term" %}
{% assign term_offset = cmd.args.offset | default: 0 %}
                    self.set_term({{ term_offset }});

{% when "prepend" %}
{% comment %} Prepend literal bytes to the accumulation buffer. Empty literals are
              filtered as :noop at parse time, so we always have content here. {% endcomment %}
                    self.prepend_bytes(b"{{ cmd.args.literal }}");

{% when "prepend_param" %}
{% comment %} Prepend parameter bytes to accumulation buffer. Parameter is &'static [u8],
              so empty slice is naturally a no-op, NUL bytes work fine. {% endcomment %}
{% assign param_name = cmd.args.param_ref %}
                    self.prepend_bytes({{ param_name }});

{% when "return" %}
{% comment %} Emit appropriate event based on return type, then return {% endcomment %}
{% if cmd.args.return_value %}
{% comment %} INTERNAL type returning a computed value {% endcomment %}
                    return {{ cmd.args.return_value }};
{% elsif cmd.args.emit_type %}
{% comment %} Explicit return type specified {% endcomment %}
{% if cmd.args.emit_mode == "mark" %}
                    on_event(Event::{{ cmd.args.emit_type }} { content: self.term(), span: self.span_from_mark() });
{% elsif cmd.args.emit_mode == "literal" %}
                    on_event(Event::{{ cmd.args.emit_type }} { content: std::borrow::Cow::Borrowed(b"{{ cmd.args.literal }}"), span: self.span() });
{% else %}
                    on_event(Event::{{ cmd.args.emit_type }} { content: std::borrow::Cow::Borrowed(b""), span: self.span() });
{% endif %}
                    return;
{% elsif return_type_info.kind == "internal" %}
{% comment %} INTERNAL type with no explicit return value - return 0 as default {% endcomment %}
                    return 0;
{% elsif cmd.args.suppress_auto_emit and return_type_info.kind == "content" %}
{% comment %} Fix #11: Inline emit already happened for CONTENT type - skip auto-emit.
              Note: BRACKET types ALWAYS emit End event regardless of inline emits,
              because End is structural, not a content event. {% endcomment %}
                    return;
{% elsif return_type_info.kind == "content" %}
                    on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                    return;
{% elsif return_type_info.kind == "bracket" %}
                    on_event(Event::{{ func.return_type }}End { span: self.span() });
                    return;
{% else %}
                    return;
{% endif %}

{% when "transition" %}
{% if cmd.args.value == "" or cmd.args.value == nil %}
                    {% comment %} Self-loop - continue {% endcomment %}
                    continue;
{% else %}
                    state = State::{{ cmd.args.value | remove: ":" | pascalcase }};
                    continue;
{% endif %}

{% when "call" %}
{% comment %} Function call - use pre-parsed name and call_args from IR {% endcomment %}
{% if cmd.args.is_error %}
{% comment %} Built-in /error(ErrorCode) - emit error and return {% endcomment %}
{% if cmd.args.call_args %}
                    on_event(Event::Error { code: ParseErrorCode::{{ cmd.args.call_args | pascalcase }}, span: self.span() });
{% else %}
                    on_event(Event::Error { code: ParseErrorCode::UnexpectedChar, span: self.span() });
{% endif %}
                    return;
{% elsif cmd.args.call_args %}
                    self.parse_{{ cmd.args.name }}({{ cmd.args.call_args | rust_expr }}, on_event);
{% else %}
                    self.parse_{{ cmd.args.name }}(on_event);
{% endif %}

{% when "assign" %}
{% if cmd.args.var and cmd.args.expr %}
                    {{ cmd.args.var }} = {{ cmd.args.expr | rust_expr }};
{% endif %}

{% when "add_assign" %}
{% if cmd.args.var and cmd.args.expr %}
                    {{ cmd.args.var }} += {{ cmd.args.expr | rust_expr }};
{% endif %}

{% when "sub_assign" %}
{% if cmd.args.var and cmd.args.expr %}
                    {{ cmd.args.var }} -= {{ cmd.args.expr | rust_expr }};
{% endif %}

{% when "emit" %}
{% comment %} Explicit emit - used for mid-function emissions {% endcomment %}
{% assign emit_type = cmd.args.value %}
                    on_event(Event::{{ emit_type }} { content: self.term(), span: self.span_from_mark() });

{% when "inline_emit_bare" %}
{% comment %} Inline emit with no payload: TypeName - CONTENT types still need content field {% endcomment %}
                    on_event(Event::{{ cmd.args.type }} { content: std::borrow::Cow::Borrowed(b""), span: self.span() });

{% when "inline_emit_mark" %}
{% comment %} Inline emit using accumulated content: TypeName(USE_MARK) {% endcomment %}
                    on_event(Event::{{ cmd.args.type }} { content: self.term(), span: self.span_from_mark() });

{% when "inline_emit_literal" %}
{% comment %} Inline emit with literal: TypeName(literal) - strip $ sigil if present {% endcomment %}
{% assign literal = cmd.args.literal | remove_first: '$' %}
                    on_event(Event::{{ cmd.args.type }} { content: std::borrow::Cow::Borrowed(b"{{ literal }}"), span: self.span() });

{% when "error" %}
{% assign error_code = cmd.args.value | pascalcase %}
                    on_event(Event::Error { code: ParseErrorCode::{{ error_code }}, span: self.span() });

{% when "keywords_lookup" %}
{% comment %} Look up accumulated content in keyword map, call fallback if not found {% endcomment %}
                    self.lookup_{{ cmd.args.name }}_or_fallback(on_event);

{% when "conditional" %}
{% comment %} Inline conditional: if/else chain {% endcomment %}
{% for clause in cmd.args.clauses %}
{% if forloop.first %}
                    if {{ clause.condition | rust_expr }} {
{% else %}
{% if clause.condition %}
                    } else if {{ clause.condition | rust_expr }} {
{% else %}
                    } else {
{% endif %}
{% endif %}
{% for nested_cmd in clause.commands %}
{% include 'command' cmd: nested_cmd, func: func, return_type_info: return_type_info, states: states %}
{% endfor %}
{% endfor %}
                    }

{% else %}
                    compile_error!("Unknown command type passed to template: {{ cmd.type }}");

{% endcase %}
