//! Generated parser - DO NOT EDIT
//!
//! Generated by descent from {{ parser }}.desc
//!
//! Callback-based recursive descent parser.
//! Call stack = element stack. True recursion handles nesting naturally.

use std::ops::Range;
{% if keywords.size > 0 %}
use phf::phf_map;
{% endif %}

/// Events emitted by the parser.
#[derive(Debug, Clone, PartialEq)]
pub enum Event<'a> {
{% for type in types %}
{% if type.kind == "bracket" %}
    {{ type.name }}Start { span: Range<usize> },
    {{ type.name }}End { span: Range<usize> },
{% elsif type.kind == "content" %}
    {{ type.name }} { content: std::borrow::Cow<'a, [u8]>, span: Range<usize> },
{% endif %}
{% endfor %}
    Error { code: ParseErrorCode, span: Range<usize> },
}

impl<'a> Event<'a> {
    /// Format event as a single line for test output.
    pub fn format_line(&self) -> String {
        match self {
{% for type in types %}
{% if type.kind == "bracket" %}
            Event::{{ type.name }}Start { span } => {
                format!("{{ type.name }}Start @ {}..{}", span.start, span.end)
            }
            Event::{{ type.name }}End { span } => {
                format!("{{ type.name }}End @ {}..{}", span.start, span.end)
            }
{% elsif type.kind == "content" %}
            Event::{{ type.name }} { content, span } => {
                let s = std::str::from_utf8(content.as_ref()).unwrap_or("<invalid utf8>");
                format!("{{ type.name }} {:?} @ {}..{}", s, span.start, span.end)
            }
{% endif %}
{% endfor %}
            Event::Error { code, span } => {
                format!("Error {:?} @ {}..{}", code, span.start, span.end)
            }
        }
    }
}

{% comment %} Generate phf keyword maps {% endcomment %}
{% for kw in keywords %}
/// Keyword lookup map for {{ kw.name }}.
/// Generated from |keywords[{{ kw.name }}] - O(1) perfect hash lookup.
static {{ kw.const_name }}: phf::Map<&'static [u8], u8> = phf_map! {
{% for m in kw.mappings %}
{% assign idx = forloop.index0 %}
    b"{{ m.keyword }}" => {{ idx }}u8,
{% endfor %}
};
{% endfor %}

/// Error codes for parse errors.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParseErrorCode {
    UnexpectedEof,
    UnexpectedChar,
{% comment %} Deduplicate error codes by return_type - multiple functions may return the same type {% endcomment %}
{% comment %} Use comma-delimited format with leading comma to avoid partial matches {% endcomment %}
{% assign seen_unclosed_types = "," %}
{% for func in functions %}
{% if func.expects_char %}
{% assign type_pattern = "," | append: func.return_type | append: "," %}
{% unless seen_unclosed_types contains type_pattern %}
    Unclosed{{ func.return_type }},
{% assign seen_unclosed_types = seen_unclosed_types | append: func.return_type | append: "," %}
{% endunless %}
{% endif %}
{% endfor %}
{% comment %} Custom error codes from /error(code) calls {% endcomment %}
{% for code in custom_error_codes %}
    {{ code | pascalcase }},
{% endfor %}
}

/// Callback-based parser.
///
/// Uses true recursive descent - the call stack IS the element stack.
pub struct Parser<'a> {
    input: &'a [u8],
    pos: usize,
    mark_pos: usize,
    term_pos: usize,
    prepend_buf: Vec<u8>,
    line: u32,
    column: u32,
}

#[allow(unused_variables, dead_code)]
impl<'a> Parser<'a> {
    /// Create a new parser for the given input.
    pub fn new(input: &'a [u8]) -> Self {
        Self {
            input,
            pos: 0,
            mark_pos: 0,
            term_pos: 0,
            prepend_buf: Vec::new(),
            line: 1,
            column: 1,
        }
    }

    /// Parse the input, calling the callback for each event.
    ///
    /// The callback receives events in document order.
    /// For backpressure, have the callback send to a bounded channel.
    pub fn parse<F>(mut self, mut on_event: F)
    where
        F: FnMut(Event<'a>),
    {
        self.parse_{{ entry_point | remove: "/" }}(&mut on_event);
    }

    // ========== Helpers ==========

    #[inline(always)]
    fn peek(&self) -> Option<u8> {
        self.input.get(self.pos).copied()
    }

{% if trace %}
    /// Format a byte for trace display (shows printable chars or escape codes).
    fn trace_byte(b: Option<u8>) -> String {
        match b {
            None => "EOF".to_string(),
            Some(b'\n') => "'\\n'".to_string(),
            Some(b'\t') => "'\\t'".to_string(),
            Some(b'\r') => "'\\r'".to_string(),
            Some(b' ') => "' '".to_string(),
            Some(b) if b.is_ascii_graphic() => format!("'{}'", b as char),
            Some(b) => format!("0x{:02x}", b),
        }
    }

    /// Format accumulated content for trace display (truncated).
    /// Shows slice content only (prepend buffer shown separately if non-empty).
    fn trace_content(&self) -> String {
        let end = if self.term_pos != usize::MAX { self.term_pos } else { self.pos };
        let slice = &self.input[self.mark_pos..end];
        let prepend_info = if self.prepend_buf.is_empty() {
            String::new()
        } else {
            format!("+{}", self.prepend_buf.len())
        };
        if slice.is_empty() && self.prepend_buf.is_empty() {
            return "[]".to_string();
        }
        let s = std::str::from_utf8(slice).unwrap_or("<binary>");
        if s.len() > 32 {
            format!("[{:?}...]{}", &s[..32], prepend_info)
        } else {
            format!("[{:?}]{}", s, prepend_info)
        }
    }
{% endif %}

    #[inline(always)]
    fn eof(&self) -> bool {
        self.pos >= self.input.len()
    }

    #[inline(always)]
    fn advance(&mut self) {
        if self.pos < self.input.len() {
            if self.input[self.pos] == b'\n' {
                self.line += 1;
                self.column = 1;
            } else {
                self.column += 1;
            }
            self.pos += 1;
        }
    }

    #[inline(always)]
    fn mark(&mut self) {
        self.mark_pos = self.pos;
        self.term_pos = usize::MAX; // Sentinel: TERM not yet called
        // Note: prepend_buf is NOT cleared here - it persists until term() consumes it.
        // This allows PREPEND to be called before a nested function that does MARK.
    }

    /// Set termination point with optional offset (e.g., -1 for one char before current)
    /// Clamps to valid range [0, input.len()] to prevent underflow/overflow.
    #[inline(always)]
    fn set_term(&mut self, offset: i32) {
        let new_pos = self.pos as i64 + offset as i64;
        self.term_pos = new_pos.clamp(0, self.input.len() as i64) as usize;
    }

    /// Prepend bytes to the accumulation buffer.
    /// Empty slice is naturally a no-op.
    #[inline(always)]
    fn prepend_bytes(&mut self, bytes: &[u8]) {
        self.prepend_buf.extend_from_slice(bytes);
    }

    /// Get accumulated content from MARK to TERM, including any prepended bytes.
    /// Returns Cow::Borrowed when no prepend (zero-copy), Cow::Owned when prepend used.
    #[inline(always)]
    fn term(&mut self) -> std::borrow::Cow<'a, [u8]> {
        // Use term_pos if set after mark, otherwise use current pos
        let end = if self.term_pos != usize::MAX { self.term_pos } else { self.pos };
        let slice = &self.input[self.mark_pos..end];

        if self.prepend_buf.is_empty() {
            std::borrow::Cow::Borrowed(slice)
        } else {
            let mut combined = std::mem::take(&mut self.prepend_buf);
            combined.extend_from_slice(slice);
            std::borrow::Cow::Owned(combined)
        }
    }

    #[inline(always)]
    fn span(&self) -> Range<usize> {
        self.pos..self.pos
    }

    #[inline(always)]
    fn span_from_mark(&self) -> Range<usize> {
        // Use term_pos if set after mark, otherwise use current pos
        let end = if self.term_pos != usize::MAX { self.term_pos } else { self.pos };
        self.mark_pos..end
    }

    #[inline(always)]
    fn col(&self) -> i32 {
        self.column as i32
    }

    /// Previous byte (0 at start of input).
    #[inline(always)]
    fn prev(&self) -> u8 {
        if self.pos > 0 {
            self.input[self.pos - 1]
        } else {
            0
        }
    }

    #[inline(always)]
    fn is_letter(b: u8) -> bool {
        b.is_ascii_alphabetic()
    }

    #[inline(always)]
    fn is_label_cont(b: u8) -> bool {
        b.is_ascii_alphanumeric() || b == b'_' || b == b'-'
    }

    #[inline(always)]
    fn is_digit(b: u8) -> bool {
        b.is_ascii_digit()
    }

    #[inline(always)]
    fn is_hex_digit(b: u8) -> bool {
        b.is_ascii_hexdigit()
    }

    #[inline(always)]
    fn is_ws(b: u8) -> bool {
        b == b' ' || b == b'\t'
    }

    #[inline(always)]
    fn is_nl(b: u8) -> bool {
        b == b'\n'
    }

{% if uses_unicode %}
    // ========== Unicode Identifier Classes ==========
    // Requires `unicode-xid` crate for full Unicode support.
    // These is_* methods work with the byte-at-a-time matching pattern.
    // For ASCII bytes, they use unicode-xid. For non-ASCII, the check
    // is done at the byte level (first byte of UTF-8 sequence).

    /// XID_Start: Can start a Unicode identifier.
    /// For ASCII, uses unicode-xid. For non-ASCII first bytes, returns true
    /// (conservative - actual validation happens via match_xid_start for multi-byte).
    #[inline(always)]
    fn is_xid_start(b: u8) -> bool {
        use unicode_xid::UnicodeXID;
        if b < 0x80 {
            (b as char).is_xid_start()
        } else {
            // Non-ASCII: could be start of valid UTF-8 XID_Start sequence
            // Return true for lead bytes (0xC2-0xF4), let advance handle it
            b >= 0xC2 && b <= 0xF4
        }
    }

    /// XID_Continue: Can continue a Unicode identifier.
    #[inline(always)]
    fn is_xid_cont(b: u8) -> bool {
        use unicode_xid::UnicodeXID;
        if b < 0x80 {
            (b as char).is_xid_continue()
        } else {
            // Non-ASCII: could be valid UTF-8 continuation or lead byte
            b >= 0x80
        }
    }

    /// XLBL_Start: Same as XID_Start (for label syntax).
    #[inline(always)]
    fn is_xlbl_start(b: u8) -> bool {
        Self::is_xid_start(b)
    }

    /// XLBL_Continue: XID_Continue + hyphen (for kebab-case labels).
    #[inline(always)]
    fn is_xlbl_cont(b: u8) -> bool {
        b == b'-' || Self::is_xid_cont(b)
    }
{% endif %}

    // ========== SCAN Methods (SIMD-accelerated via memchr) ==========

    /// Scan forward to find first occurrence of b1, returns matched byte or None for EOF.
    #[inline]
    fn scan_to1(&mut self, b1: u8) -> Option<u8> {
        match memchr::memchr(b1, &self.input[self.pos..]) {
            Some(offset) => {
                // Update line/column for skipped chars
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                // Advance to end
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1 or b2.
    #[inline]
    fn scan_to2(&mut self, b1: u8, b2: u8) -> Option<u8> {
        match memchr::memchr2(b1, b2, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1, b2, or b3.
    #[inline]
    fn scan_to3(&mut self, b1: u8, b2: u8, b3: u8) -> Option<u8> {
        match memchr::memchr3(b1, b2, b3, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1, b2, b3, or b4 (chained memchr).
    #[inline]
    fn scan_to4(&mut self, b1: u8, b2: u8, b3: u8, b4: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr(b4, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Scan forward to find first occurrence of b1..b5 (chained memchr).
    #[inline]
    fn scan_to5(&mut self, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr2(b4, b5, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Scan forward to find first occurrence of b1..b6 (chained memchr).
    #[inline]
    fn scan_to6(&mut self, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr3(b4, b5, b6, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Apply scan offset result, updating position and line/column.
    #[inline]
    fn apply_scan_offset(&mut self, offset: Option<usize>) -> Option<u8> {
        match offset {
            Some(off) => {
                for &b in &self.input[self.pos..self.pos + off] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += off;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

{% comment %} Generate keyword lookup methods {% endcomment %}
{% for kw in keywords %}
    // ========== Keyword Lookup: {{ kw.name }} ==========

    /// Look up accumulated content in {{ kw.name }} keywords.
    /// Returns true if a keyword matched (event emitted), false otherwise.
    fn lookup_{{ kw.name }}<F>(&mut self, on_event: &mut F) -> bool
    where
        F: FnMut(Event<'a>),
    {
        let content = self.term();
        if let Some(&id) = {{ kw.const_name }}.get(content.as_ref()) {
            let span = self.span_from_mark();
            match id {
{% for m in kw.mappings %}
{% assign idx = forloop.index0 %}
                {{ idx }} => on_event(Event::{{ m.event_type }} { content, span }),
{% endfor %}
                _ => unreachable!("keyword map contains only valid ids"),
            }
            true
        } else {
            false
        }
    }

    /// Look up and emit keyword, or call fallback function.
    fn lookup_{{ kw.name }}_or_fallback<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(Event<'a>),
    {
        if !self.lookup_{{ kw.name }}(on_event) {
{% if kw.fallback_func %}
{% if kw.fallback_args %}
            self.parse_{{ kw.fallback_func }}({{ kw.fallback_args }}, on_event);
{% else %}
            self.parse_{{ kw.fallback_func }}(on_event);
{% endif %}
{% else %}
            // No fallback - keyword not found is a no-op
{% endif %}
        }
    }
{% endfor %}

    // ========== Generated Parse Functions ==========

{% for func in functions %}
    {% comment %} Determine return type info {% endcomment %}
    {% assign return_type_info = nil %}
    {% for t in types %}
        {% if t.name == func.return_type %}
            {% assign return_type_info = t %}
        {% endif %}
    {% endfor %}

    /// Parse {{ func.name }}{% if func.return_type %} -> {{ func.return_type }}{% endif %}
    {% if func.params.size > 0 %}
    fn parse_{{ func.name }}<F>(&mut self, {% for param in func.params %}{{ param }}: {% if func.param_types[param] == "byte" %}u8{% elsif func.param_types[param] == "bytes" %}&'static [u8]{% else %}i32{% endif %}, {% endfor %}on_event: &mut F){% if return_type_info.kind == "internal" %} -> i32{% endif %}
    {% else %}
    fn parse_{{ func.name }}<F>(&mut self, on_event: &mut F){% if return_type_info.kind == "internal" %} -> i32{% endif %}
    {% endif %}
    where
        F: FnMut(Event<'a>),
    {
        {% if trace %}eprintln!("TRACE: L{{ func.lineno }} ENTER {{ func.name }} | byte={} pos={}", Self::trace_byte(self.peek()), self.pos);{% endif %}

        {% comment %} BRACKET types: emit Start on entry {% endcomment %}
        {% if return_type_info.kind == "bracket" %}
        let start_span = self.span();
        on_event(Event::{{ func.return_type }}Start { span: start_span.clone() });
        {% endif %}

        {% comment %} CONTENT types: MARK on entry {% endcomment %}
        {% if return_type_info.kind == "content" %}
        self.mark();
        {% endif %}

        {% comment %} Local variables {% endcomment %}
        {% for local in func.locals %}
        let mut {{ local[0] }}: i32 = 0;
        {% endfor %}

        {% comment %} State machine {% endcomment %}
        {% if func.states.size == 0 %}
        {% comment %} No states - immediate return (stateless function) {% endcomment %}
        {% if return_type_info.kind == "content" %}
        on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
        {% elsif return_type_info.kind == "bracket" %}
        on_event(Event::{{ func.return_type }}End { span: self.span() });
        {% elsif return_type_info.kind == "internal" %}
        return 0;
        {% endif %}
        {% elsif func.states.size == 1 %}
        {% comment %} Single state - no enum needed {% endcomment %}
        {% assign state = func.states.first %}
        loop {
            {% if state.scannable %}
            {% comment %} SCAN-first optimization {% endcomment %}
            {% assign scan_count = state.scan_chars.size %}
            {% if scan_count == 1 %}
            match self.scan_to1({{ state.scan_chars[0] | escape_rust_char }}) {
            {% elsif scan_count == 2 %}
            match self.scan_to2({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}) {
            {% elsif scan_count == 3 %}
            match self.scan_to3({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}) {
            {% elsif scan_count == 4 %}
            match self.scan_to4({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}) {
            {% elsif scan_count == 5 %}
            match self.scan_to5({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}, {{ state.scan_chars[4] | escape_rust_char }}) {
            {% elsif scan_count == 6 %}
            match self.scan_to6({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}, {{ state.scan_chars[4] | escape_rust_char }}, {{ state.scan_chars[5] | escape_rust_char }}) {
            {% endif %}
                {% for kase in state.cases %}
                {% unless kase.is_default %}
                {% if kase.is_conditional %}
                _ if {{ kase.condition | rust_expr }} => {
                {% elsif kase.param_ref %}
                {% comment %} Parameter reference: match against param value {% endcomment %}
                Some(b) if b == {{ kase.param_ref }} => {
                {% elsif kase.special_class and kase.chars.size > 0 %}
                {% comment %} Combined: class + literal chars {% endcomment %}
                Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                {% elsif kase.special_class %}
                Some(b) if Self::is_{{ kase.special_class }}(b) => {
                {% elsif kase.chars.size == 1 %}
                Some({{ kase.chars[0] | escape_rust_char }}) => {
                {% elsif kase.chars.size > 1 %}
                Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                {% else %}
                Some(_) => {
                {% endif %}
                    {% if trace %}eprintln!("TRACE: L{{ kase.lineno }} {{ func.name }}:{{ state.name }}{% if kase.substate %}.{{ kase.substate }}{% endif %} | byte={} term={} pos={}", Self::trace_byte(self.peek()), self.trace_content(), self.pos);{% endif %}
                    {% for cmd in kase.commands %}
                    {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info %}
                    {% endfor %}
                }
                {% endunless %}
                {% endfor %}
                None => {
                    {% if trace %}eprintln!("TRACE: L{{ state.lineno }} {{ func.name }}:{{ state.name }} EOF | term={} pos={}", self.trace_content(), self.pos);{% endif %}
                    {% comment %} EOF handling - check for explicit |eof handler first {% endcomment %}
                    {% if state.eof_handler.size > 0 %}
                    {% for cmd in state.eof_handler %}
                    {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info %}
                    {% endfor %}
                    {% elsif func.eof_handler.size > 0 %}
                    {% for cmd in func.eof_handler %}
                    {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info %}
                    {% endfor %}
                    {% else %}
                    {% if return_type_info.kind == "content" %}
                    on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                    {% endif %}
                    {% if func.expects_char %}
                    on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                    {% elsif return_type_info.kind == "bracket" %}
                    on_event(Event::{{ func.return_type }}End { span: self.span() });
                    {% endif %}
                    {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
                    {% endif %}
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
            {% else %}
            {% comment %} Non-scannable: check EOF first, then match {% endcomment %}
            if self.eof() {
                {% if trace %}eprintln!("TRACE: L{{ state.lineno }} {{ func.name }}:{{ state.name }} EOF | term={} pos={}", self.trace_content(), self.pos);{% endif %}
                {% if state.eof_handler.size > 0 %}
                {% comment %} Fix #13: Explicit |eof handler - use its commands {% endcomment %}
                {% for cmd in state.eof_handler %}
                {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info %}
                {% endfor %}
                {% elsif func.eof_handler.size > 0 %}
                {% comment %} Function-level |eof handler {% endcomment %}
                {% for cmd in func.eof_handler %}
                {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info %}
                {% endfor %}
                {% else %}
                {% comment %} Default EOF behavior based on return type {% endcomment %}
                {% if return_type_info.kind == "content" %}
                on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                {% endif %}
                {% if func.expects_char %}
                on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                {% elsif return_type_info.kind == "bracket" %}
                on_event(Event::{{ func.return_type }}End { span: self.span() });
                {% endif %}
                {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
                {% endif %}
            }
            match self.peek() {
                {% for kase in state.cases %}
                {% if kase.is_default %}
                _ => {
                {% elsif kase.is_conditional %}
                _ if {{ kase.condition | rust_expr }} => {
                {% elsif kase.param_ref %}
                Some(b) if b == {{ kase.param_ref }} => {
                {% elsif kase.special_class and kase.chars.size > 0 %}
                Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                {% elsif kase.special_class %}
                Some(b) if Self::is_{{ kase.special_class }}(b) => {
                {% elsif kase.chars.size == 1 %}
                Some({{ kase.chars[0] | escape_rust_char }}) => {
                {% elsif kase.chars.size > 1 %}
                Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                {% else %}
                Some(_) => {
                {% endif %}
                    {% if trace %}eprintln!("TRACE: L{{ kase.lineno }} {{ func.name }}:{{ state.name }}{% if kase.substate %}.{{ kase.substate }}{% endif %} | byte={} term={} pos={}", Self::trace_byte(self.peek()), self.trace_content(), self.pos);{% endif %}
                    {% for cmd in kase.commands %}
                    {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info %}
                    {% endfor %}
                }
                {% endfor %}
                {% unless state.has_default %}
                {% comment %} Add default arm if state has no explicit default case {% endcomment %}
                _ => {
                    {% if trace %}eprintln!("TRACE: {{ func.name }}:{{ state.name }} UNHANDLED | byte={} pos={}", Self::trace_byte(self.peek()), self.pos);{% endif %}
                    {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
                }
                {% endunless %}
            }
            {% endif %}
        }
        {% else %}
        {% comment %} Multiple states - use enum {% endcomment %}
        #[derive(Clone, Copy)]
        enum State { {% for state in func.states %}{{ state.name | pascalcase }}, {% endfor %} }
        let mut state = State::{{ func.states.first.name | pascalcase }};

        loop {
            match state {
            {% for state in func.states %}
                State::{{ state.name | pascalcase }} => {
                    {% if state.scannable %}
                    {% assign scan_count = state.scan_chars.size %}
                    {% if scan_count == 1 %}
                    match self.scan_to1({{ state.scan_chars[0] | escape_rust_char }}) {
                    {% elsif scan_count == 2 %}
                    match self.scan_to2({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}) {
                    {% elsif scan_count == 3 %}
                    match self.scan_to3({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}) {
                    {% elsif scan_count == 4 %}
                    match self.scan_to4({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}) {
                    {% elsif scan_count == 5 %}
                    match self.scan_to5({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}, {{ state.scan_chars[4] | escape_rust_char }}) {
                    {% elsif scan_count == 6 %}
                    match self.scan_to6({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}, {{ state.scan_chars[4] | escape_rust_char }}, {{ state.scan_chars[5] | escape_rust_char }}) {
                    {% endif %}
                        {% for kase in state.cases %}
                        {% unless kase.is_default %}
                        {% if kase.is_conditional %}
                        _ if {{ kase.condition | rust_expr }} => {
                        {% elsif kase.param_ref %}
                        Some(b) if b == {{ kase.param_ref }} => {
                        {% elsif kase.special_class and kase.chars.size > 0 %}
                        Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                        {% elsif kase.special_class %}
                        Some(b) if Self::is_{{ kase.special_class }}(b) => {
                        {% elsif kase.chars.size == 1 %}
                        Some({{ kase.chars[0] | escape_rust_char }}) => {
                        {% elsif kase.chars.size > 1 %}
                        Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                        {% else %}
                        Some(_) => {
                        {% endif %}
                            {% if trace %}eprintln!("TRACE: L{{ kase.lineno }} {{ func.name }}:{{ state.name }}{% if kase.substate %}.{{ kase.substate }}{% endif %} | byte={} term={} pos={}", Self::trace_byte(self.peek()), self.trace_content(), self.pos);{% endif %}
                            {% for cmd in kase.commands %}
                            {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info, states: func.states %}
                            {% endfor %}
                        }
                        {% endunless %}
                        {% endfor %}
                        None => {
                            {% if trace %}eprintln!("TRACE: L{{ state.lineno }} {{ func.name }}:{{ state.name }} EOF | term={} pos={}", self.trace_content(), self.pos);{% endif %}
                            {% comment %} EOF handling - check for explicit |eof handler first {% endcomment %}
                            {% if state.eof_handler.size > 0 %}
                            {% for cmd in state.eof_handler %}
                            {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info, states: func.states %}
                            {% endfor %}
                            {% elsif func.eof_handler.size > 0 %}
                            {% for cmd in func.eof_handler %}
                            {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info, states: func.states %}
                            {% endfor %}
                            {% else %}
                            {% if return_type_info.kind == "content" %}
                            on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                            {% endif %}
                            {% if func.expects_char %}
                            on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                            {% elsif return_type_info.kind == "bracket" %}
                            on_event(Event::{{ func.return_type }}End { span: self.span() });
                            {% endif %}
                            {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
                            {% endif %}
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                    {% else %}
                    {% if state.is_unconditional %}
                    {% comment %} Unconditional state: execute commands immediately without byte match {% endcomment %}
                    {% assign kase = state.cases.first %}
                    {% if trace %}eprintln!("TRACE: L{{ kase.lineno }} {{ func.name }}:{{ state.name }}{% if kase.substate %}.{{ kase.substate }}{% endif %} UNCONDITIONAL | term={} pos={}", self.trace_content(), self.pos);{% endif %}
                    {% for cmd in kase.commands %}
                    {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info, states: func.states %}
                    {% endfor %}
                    {% else %}
                    {% comment %} Non-scannable: check EOF first {% endcomment %}
                    if self.eof() {
                        {% if trace %}eprintln!("TRACE: L{{ state.lineno }} {{ func.name }}:{{ state.name }} EOF | term={} pos={}", self.trace_content(), self.pos);{% endif %}
                        {% if state.eof_handler.size > 0 %}
                        {% for cmd in state.eof_handler %}
                        {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info, states: func.states %}
                        {% endfor %}
                        {% elsif func.eof_handler.size > 0 %}
                        {% for cmd in func.eof_handler %}
                        {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info, states: func.states %}
                        {% endfor %}
                        {% else %}
                        {% if return_type_info.kind == "content" %}
                        on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                        {% endif %}
                        {% if func.expects_char %}
                        on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                        {% elsif return_type_info.kind == "bracket" %}
                        on_event(Event::{{ func.return_type }}End { span: self.span() });
                        {% endif %}
                        {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
                        {% endif %}
                    }
                    match self.peek() {
                        {% for kase in state.cases %}
                        {% if kase.is_default %}
                        _ => {
                        {% elsif kase.is_conditional %}
                        _ if {{ kase.condition | rust_expr }} => {
                        {% elsif kase.param_ref %}
                        Some(b) if b == {{ kase.param_ref }} => {
                        {% elsif kase.special_class and kase.chars.size > 0 %}
                        Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                        {% elsif kase.special_class %}
                        Some(b) if Self::is_{{ kase.special_class }}(b) => {
                        {% elsif kase.chars.size == 1 %}
                        Some({{ kase.chars[0] | escape_rust_char }}) => {
                        {% elsif kase.chars.size > 1 %}
                        Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                        {% else %}
                        Some(_) => {
                        {% endif %}
                            {% if trace %}eprintln!("TRACE: L{{ kase.lineno }} {{ func.name }}:{{ state.name }}{% if kase.substate %}.{{ kase.substate }}{% endif %} | byte={} term={} pos={}", Self::trace_byte(self.peek()), self.trace_content(), self.pos);{% endif %}
                            {% for cmd in kase.commands %}
                            {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info, states: func.states %}
                            {% endfor %}
                        }
                        {% endfor %}
                        {% unless state.has_default %}
                        {% comment %} Add default arm if state has no explicit default case {% endcomment %}
                        _ => {
                            {% if trace %}eprintln!("TRACE: {{ func.name }}:{{ state.name }} UNHANDLED | byte={} pos={}", Self::trace_byte(self.peek()), self.pos);{% endif %}
                            {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
                        }
                        {% endunless %}
                    }
                    {% endif %}
                    {% endif %}
                }
            {% endfor %}
            }
        }
        {% endif %}

        {% comment %} Note: Unreachable code below - returns happen in command handling {% endcomment %}
        {% comment %} This is intentional - the loop above handles all exits {% endcomment %}
    }

{% endfor %}
}

// ============================================================================
// Streaming Parser (multi-chunk support)
// ============================================================================

/// Result of parsing a chunk in streaming mode.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParseResult {
    /// Parsing completed successfully (EOF reached).
    Complete,
    /// More data needed - provide another chunk.
    NeedMoreData,
}

/// Event with owned content for streaming across chunk boundaries.
#[derive(Debug, Clone, PartialEq)]
pub enum StreamEvent {
{% for type in types %}
{% if type.kind == "bracket" %}
    {{ type.name }}Start { span: Range<usize> },
    {{ type.name }}End { span: Range<usize> },
{% elsif type.kind == "content" %}
    {{ type.name }} { content: Vec<u8>, span: Range<usize> },
{% endif %}
{% endfor %}
    Error { code: ParseErrorCode, span: Range<usize> },
}

impl StreamEvent {
    /// Convert from borrowed Event to owned StreamEvent.
    fn from_event(event: Event<'_>, offset: usize) -> Self {
        match event {
{% for type in types %}
{% if type.kind == "bracket" %}
            Event::{{ type.name }}Start { span } => {
                StreamEvent::{{ type.name }}Start { span: (span.start + offset)..(span.end + offset) }
            }
            Event::{{ type.name }}End { span } => {
                StreamEvent::{{ type.name }}End { span: (span.start + offset)..(span.end + offset) }
            }
{% elsif type.kind == "content" %}
            Event::{{ type.name }} { content, span } => {
                StreamEvent::{{ type.name }} {
                    content: content.into_owned(),
                    span: (span.start + offset)..(span.end + offset),
                }
            }
{% endif %}
{% endfor %}
            Event::Error { code, span } => {
                StreamEvent::Error { code, span: (span.start + offset)..(span.end + offset) }
            }
        }
    }
}

/// Streaming parser for chunk-by-chunk input.
///
/// Wraps the single-buffer `Parser` to handle input arriving in chunks.
/// Buffers incomplete content across chunk boundaries.
///
/// # Example
///
/// ```ignore
/// let mut parser = StreamingParser::new();
/// loop {
///     match parser.parse(chunk, |event| handle(event)) {
///         ParseResult::Complete => break,
///         ParseResult::NeedMoreData => {
///             chunk = get_next_chunk();
///             if chunk.is_empty() {
///                 parser.finish(|event| handle(event));
///                 break;
///             }
///         }
///     }
/// }
/// ```
pub struct StreamingParser {
    /// Buffer for incomplete content at chunk boundaries.
    buffer: Vec<u8>,
    /// Maximum buffer size before error (default 4KB).
    max_buffer: usize,
    /// Global byte offset for span calculation.
    global_offset: usize,
    /// Line number (persists across chunks).
    line: u32,
    /// Column number (persists across chunks).
    column: u32,
}

impl Default for StreamingParser {
    fn default() -> Self {
        Self::new()
    }
}

impl StreamingParser {
    /// Create a new streaming parser with default settings.
    pub fn new() -> Self {
        Self::with_max_buffer(4096)
    }

    /// Create a streaming parser with custom buffer limit.
    pub fn with_max_buffer(max_buffer: usize) -> Self {
        Self {
            buffer: Vec::new(),
            max_buffer,
            global_offset: 0,
            line: 1,
            column: 1,
        }
    }

    /// Parse a chunk of input, emitting events for complete lines.
    ///
    /// Uses line-oriented streaming: only parses complete lines (ending in `\n`).
    /// Incomplete lines are buffered until more data arrives.
    ///
    /// Returns `NeedMoreData` if the chunk ends mid-line.
    /// Call `finish()` after the last chunk to handle any remaining content.
    pub fn parse<F>(&mut self, chunk: &[u8], mut on_event: F) -> ParseResult
    where
        F: FnMut(StreamEvent),
    {
        // Append new chunk to buffer
        self.buffer.extend_from_slice(chunk);

        if self.buffer.is_empty() {
            return ParseResult::NeedMoreData;
        }

        // Check buffer size limit
        if self.buffer.len() > self.max_buffer {
            on_event(StreamEvent::Error {
                code: ParseErrorCode::UnexpectedEof, // Buffer overflow
                span: self.global_offset..self.global_offset,
            });
            self.buffer.clear();
            return ParseResult::Complete;
        }

        // Find last complete line (ending with \n)
        let last_newline = self.buffer.iter().rposition(|&b| b == b'\n');

        let parse_end = match last_newline {
            Some(pos) => pos + 1, // Include the newline
            None => return ParseResult::NeedMoreData, // No complete line yet
        };

        // Extract complete lines to parse
        let to_parse: Vec<u8> = self.buffer.drain(..parse_end).collect();
        let offset = self.global_offset;

        // Parse complete lines
        let mut inner = Parser::new(&to_parse);
        inner.line = self.line;
        inner.column = self.column;

        inner.parse(|event| {
            on_event(StreamEvent::from_event(event, offset));
        });

        // Update state
        self.global_offset += to_parse.len();
        for &b in &to_parse {
            if b == b'\n' {
                self.line += 1;
                self.column = 1;
            } else {
                self.column += 1;
            }
        }

        ParseResult::NeedMoreData
    }

    /// Signal end of input and handle any remaining buffered content.
    ///
    /// This triggers EOF handling for any incomplete constructs.
    pub fn finish<F>(mut self, mut on_event: F)
    where
        F: FnMut(StreamEvent),
    {
        if self.buffer.is_empty() {
            return;
        }

        // Parse remaining buffer - this will hit EOF
        let input = std::mem::take(&mut self.buffer);
        let offset = self.global_offset;

        let mut inner = Parser::new(&input);
        inner.line = self.line;
        inner.column = self.column;

        inner.parse(|event| {
            on_event(StreamEvent::from_event(event, offset));
        });
    }

    /// Returns the current global byte offset.
    pub fn offset(&self) -> usize {
        self.global_offset
    }

    /// Returns the current line number.
    pub fn line(&self) -> u32 {
        self.line
    }

    /// Returns the current column number.
    pub fn column(&self) -> u32 {
        self.column
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_basic() {
        // Basic smoke test - actual tests depend on parser semantics
        let input = b"";
        let mut events = Vec::new();
        Parser::new(input).parse(|e| events.push(e));
        // Events depend on the specific parser
    }
}
