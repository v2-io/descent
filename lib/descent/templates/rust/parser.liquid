//! Generated parser - DO NOT EDIT
//!
//! Generated by descent from {{ parser }}.desc
//!
//! Callback-based recursive descent parser.
//! Call stack = element stack. True recursion handles nesting naturally.

use std::ops::Range;

/// Events emitted by the parser.
#[derive(Debug, Clone, PartialEq)]
pub enum Event<'a> {
{% for type in types %}
{% if type.kind == "bracket" %}
    {{ type.name }}Start { span: Range<usize> },
    {{ type.name }}End { span: Range<usize> },
{% elsif type.kind == "content" %}
    {{ type.name }} { content: &'a [u8], span: Range<usize> },
{% endif %}
{% endfor %}
    Error { code: ParseErrorCode, span: Range<usize> },
}

impl<'a> Event<'a> {
    /// Format event as a single line for test output.
    pub fn format_line(&self) -> String {
        match self {
{% for type in types %}
{% if type.kind == "bracket" %}
            Event::{{ type.name }}Start { span } => {
                format!("{{ type.name }}Start @ {}..{}", span.start, span.end)
            }
            Event::{{ type.name }}End { span } => {
                format!("{{ type.name }}End @ {}..{}", span.start, span.end)
            }
{% elsif type.kind == "content" %}
            Event::{{ type.name }} { content, span } => {
                let s = std::str::from_utf8(content).unwrap_or("<invalid utf8>");
                format!("{{ type.name }} {:?} @ {}..{}", s, span.start, span.end)
            }
{% endif %}
{% endfor %}
            Event::Error { code, span } => {
                format!("Error {:?} @ {}..{}", code, span.start, span.end)
            }
        }
    }
}

/// Error codes for parse errors.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParseErrorCode {
    UnexpectedEof,
    UnexpectedChar,
{% comment %} Deduplicate error codes by return_type - multiple functions may return the same type {% endcomment %}
{% comment %} Use comma-delimited format with leading comma to avoid partial matches {% endcomment %}
{% assign seen_unclosed_types = "," %}
{% for func in functions %}
{% if func.expects_char %}
{% assign type_pattern = "," | append: func.return_type | append: "," %}
{% unless seen_unclosed_types contains type_pattern %}
    Unclosed{{ func.return_type }},
{% assign seen_unclosed_types = seen_unclosed_types | append: func.return_type | append: "," %}
{% endunless %}
{% endif %}
{% endfor %}
{% comment %} Custom error codes from /error(code) calls {% endcomment %}
{% for code in custom_error_codes %}
    {{ code | pascalcase }},
{% endfor %}
}

/// Callback-based parser.
///
/// Uses true recursive descent - the call stack IS the element stack.
pub struct Parser<'a> {
    input: &'a [u8],
    pos: usize,
    mark_pos: usize,
    term_pos: usize,
    line: u32,
    column: u32,
}

#[allow(unused_variables)]
impl<'a> Parser<'a> {
    /// Create a new parser for the given input.
    pub fn new(input: &'a [u8]) -> Self {
        Self {
            input,
            pos: 0,
            mark_pos: 0,
            term_pos: 0,
            line: 1,
            column: 1,
        }
    }

    /// Parse the input, calling the callback for each event.
    ///
    /// The callback receives events in document order.
    /// For backpressure, have the callback send to a bounded channel.
    pub fn parse<F>(mut self, mut on_event: F)
    where
        F: FnMut(Event<'a>),
    {
        self.parse_{{ entry_point | remove: "/" }}(&mut on_event);
    }

    // ========== Helpers ==========

    #[inline(always)]
    fn peek(&self) -> Option<u8> {
        self.input.get(self.pos).copied()
    }

    #[inline(always)]
    fn eof(&self) -> bool {
        self.pos >= self.input.len()
    }

    #[inline(always)]
    fn advance(&mut self) {
        if self.pos < self.input.len() {
            if self.input[self.pos] == b'\n' {
                self.line += 1;
                self.column = 1;
            } else {
                self.column += 1;
            }
            self.pos += 1;
        }
    }

    #[inline(always)]
    fn mark(&mut self) {
        self.mark_pos = self.pos;
        self.term_pos = self.pos; // Reset term position
    }

    /// Set termination point with optional offset (e.g., -1 for one char before current)
    /// Clamps to valid range [0, input.len()] to prevent underflow/overflow.
    #[inline(always)]
    fn set_term(&mut self, offset: i32) {
        let new_pos = self.pos as i64 + offset as i64;
        self.term_pos = new_pos.clamp(0, self.input.len() as i64) as usize;
    }

    #[inline(always)]
    fn term(&self) -> &'a [u8] {
        // Use term_pos if set after mark, otherwise use current pos
        let end = if self.term_pos > self.mark_pos { self.term_pos } else { self.pos };
        &self.input[self.mark_pos..end]
    }

    #[inline(always)]
    fn span(&self) -> Range<usize> {
        self.pos..self.pos
    }

    #[inline(always)]
    fn span_from_mark(&self) -> Range<usize> {
        // Use term_pos if set after mark, otherwise use current pos
        let end = if self.term_pos > self.mark_pos { self.term_pos } else { self.pos };
        self.mark_pos..end
    }

    #[inline(always)]
    fn col(&self) -> i32 {
        self.column as i32
    }

    /// Previous byte (0 at start of input).
    #[inline(always)]
    fn prev(&self) -> u8 {
        if self.pos > 0 {
            self.input[self.pos - 1]
        } else {
            0
        }
    }

    #[inline(always)]
    fn is_letter(b: u8) -> bool {
        b.is_ascii_alphabetic()
    }

    #[inline(always)]
    fn is_label_cont(b: u8) -> bool {
        b.is_ascii_alphanumeric() || b == b'_' || b == b'-'
    }

    // ========== SCAN Methods (SIMD-accelerated via memchr) ==========

    /// Scan forward to find first occurrence of b1, returns matched byte or None for EOF.
    #[inline]
    fn scan_to1(&mut self, b1: u8) -> Option<u8> {
        match memchr::memchr(b1, &self.input[self.pos..]) {
            Some(offset) => {
                // Update line/column for skipped chars
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                // Advance to end
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1 or b2.
    #[inline]
    fn scan_to2(&mut self, b1: u8, b2: u8) -> Option<u8> {
        match memchr::memchr2(b1, b2, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1, b2, or b3.
    #[inline]
    fn scan_to3(&mut self, b1: u8, b2: u8, b3: u8) -> Option<u8> {
        match memchr::memchr3(b1, b2, b3, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1, b2, b3, or b4 (chained memchr).
    #[inline]
    fn scan_to4(&mut self, b1: u8, b2: u8, b3: u8, b4: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr(b4, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Scan forward to find first occurrence of b1..b5 (chained memchr).
    #[inline]
    fn scan_to5(&mut self, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr2(b4, b5, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Scan forward to find first occurrence of b1..b6 (chained memchr).
    #[inline]
    fn scan_to6(&mut self, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8) -> Option<u8> {
        let haystack = &self.input[self.pos..];
        let p1 = memchr::memchr3(b1, b2, b3, haystack);
        let p2 = memchr::memchr3(b4, b5, b6, haystack);
        let offset = match (p1, p2) {
            (Some(x), Some(y)) => Some(x.min(y)),
            (Some(x), None) | (None, Some(x)) => Some(x),
            (None, None) => None,
        };
        self.apply_scan_offset(offset)
    }

    /// Apply scan offset result, updating position and line/column.
    #[inline]
    fn apply_scan_offset(&mut self, offset: Option<usize>) -> Option<u8> {
        match offset {
            Some(off) => {
                for &b in &self.input[self.pos..self.pos + off] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += off;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    // ========== Generated Parse Functions ==========

{% for func in functions %}
    {% comment %} Determine return type info {% endcomment %}
    {% assign return_type_info = nil %}
    {% for t in types %}
        {% if t.name == func.return_type %}
            {% assign return_type_info = t %}
        {% endif %}
    {% endfor %}

    /// Parse {{ func.name }}{% if func.return_type %} -> {{ func.return_type }}{% endif %}
    {% if func.params.size > 0 %}
    fn parse_{{ func.name }}<F>(&mut self, {% for param in func.params %}{{ param }}: i32, {% endfor %}on_event: &mut F){% if return_type_info.kind == "internal" %} -> i32{% endif %}
    {% else %}
    fn parse_{{ func.name }}<F>(&mut self, on_event: &mut F){% if return_type_info.kind == "internal" %} -> i32{% endif %}
    {% endif %}
    where
        F: FnMut(Event<'a>),
    {
        {% if trace %}eprintln!("TRACE: enter {{ func.name }}");{% endif %}

        {% comment %} BRACKET types: emit Start on entry {% endcomment %}
        {% if return_type_info.kind == "bracket" %}
        let start_span = self.span();
        on_event(Event::{{ func.return_type }}Start { span: start_span.clone() });
        {% endif %}

        {% comment %} CONTENT types: MARK on entry {% endcomment %}
        {% if return_type_info.kind == "content" %}
        self.mark();
        {% endif %}

        {% comment %} Local variables {% endcomment %}
        {% for local in func.locals %}
        let mut {{ local[0] }}: i32 = 0;
        {% endfor %}

        {% comment %} State machine {% endcomment %}
        {% if func.states.size == 0 %}
        {% comment %} No states - immediate return (stateless function) {% endcomment %}
        {% if return_type_info.kind == "content" %}
        on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
        {% elsif return_type_info.kind == "bracket" %}
        on_event(Event::{{ func.return_type }}End { span: self.span() });
        {% elsif return_type_info.kind == "internal" %}
        return 0;
        {% endif %}
        {% elsif func.states.size == 1 %}
        {% comment %} Single state - no enum needed {% endcomment %}
        {% assign state = func.states.first %}
        loop {
            {% if state.scannable %}
            {% comment %} SCAN-first optimization {% endcomment %}
            {% assign scan_count = state.scan_chars.size %}
            {% if scan_count == 1 %}
            match self.scan_to1({{ state.scan_chars[0] | escape_rust_char }}) {
            {% elsif scan_count == 2 %}
            match self.scan_to2({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}) {
            {% elsif scan_count == 3 %}
            match self.scan_to3({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}) {
            {% elsif scan_count == 4 %}
            match self.scan_to4({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}) {
            {% elsif scan_count == 5 %}
            match self.scan_to5({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}, {{ state.scan_chars[4] | escape_rust_char }}) {
            {% elsif scan_count == 6 %}
            match self.scan_to6({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}, {{ state.scan_chars[4] | escape_rust_char }}, {{ state.scan_chars[5] | escape_rust_char }}) {
            {% endif %}
                {% for kase in state.cases %}
                {% unless kase.is_default %}
                {% if kase.special_class and kase.chars.size > 0 %}
                {% comment %} Combined: class + literal chars {% endcomment %}
                Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                {% elsif kase.special_class %}
                Some(b) if Self::is_{{ kase.special_class }}(b) => {
                {% elsif kase.chars.size == 1 %}
                Some({{ kase.chars[0] | escape_rust_char }}) => {
                {% elsif kase.chars.size > 1 %}
                Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                {% else %}
                Some(_) => {
                {% endif %}
                    {% for cmd in kase.commands %}
                    {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info %}
                    {% endfor %}
                }
                {% endunless %}
                {% endfor %}
                None => {
                    {% comment %} EOF handling with EXPECTS inference {% endcomment %}
                    {% if return_type_info.kind == "content" %}
                    on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                    {% endif %}
                    {% if func.expects_char %}
                    on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                    {% elsif return_type_info.kind == "bracket" %}
                    on_event(Event::{{ func.return_type }}End { span: self.span() });
                    {% endif %}
                    {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
            {% else %}
            {% comment %} Non-scannable: check EOF first, then match {% endcomment %}
            if self.eof() {
                {% if return_type_info.kind == "content" %}
                on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                {% endif %}
                {% if func.expects_char %}
                on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                {% elsif return_type_info.kind == "bracket" %}
                on_event(Event::{{ func.return_type }}End { span: self.span() });
                {% endif %}
                {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
            }
            match self.peek() {
                {% for kase in state.cases %}
                {% if kase.is_default %}
                _ => {
                {% elsif kase.is_conditional %}
                _ if {{ kase.condition | rust_expr }} => {
                {% elsif kase.special_class and kase.chars.size > 0 %}
                Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                {% elsif kase.special_class %}
                Some(b) if Self::is_{{ kase.special_class }}(b) => {
                {% elsif kase.chars.size == 1 %}
                Some({{ kase.chars[0] | escape_rust_char }}) => {
                {% elsif kase.chars.size > 1 %}
                Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                {% else %}
                Some(_) => {
                {% endif %}
                    {% for cmd in kase.commands %}
                    {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info %}
                    {% endfor %}
                }
                {% endfor %}
                {% unless state.has_default %}
                {% comment %} Add default arm if state has no explicit default case {% endcomment %}
                _ => {
                    {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
                }
                {% endunless %}
            }
            {% endif %}
        }
        {% else %}
        {% comment %} Multiple states - use enum {% endcomment %}
        #[derive(Clone, Copy)]
        enum State { {% for state in func.states %}{{ state.name | pascalcase }}, {% endfor %} }
        let mut state = State::{{ func.states.first.name | pascalcase }};

        loop {
            match state {
            {% for state in func.states %}
                State::{{ state.name | pascalcase }} => {
                    {% if state.scannable %}
                    {% assign scan_count = state.scan_chars.size %}
                    {% if scan_count == 1 %}
                    match self.scan_to1({{ state.scan_chars[0] | escape_rust_char }}) {
                    {% elsif scan_count == 2 %}
                    match self.scan_to2({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}) {
                    {% elsif scan_count == 3 %}
                    match self.scan_to3({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}) {
                    {% elsif scan_count == 4 %}
                    match self.scan_to4({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}) {
                    {% elsif scan_count == 5 %}
                    match self.scan_to5({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}, {{ state.scan_chars[4] | escape_rust_char }}) {
                    {% elsif scan_count == 6 %}
                    match self.scan_to6({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}, {{ state.scan_chars[3] | escape_rust_char }}, {{ state.scan_chars[4] | escape_rust_char }}, {{ state.scan_chars[5] | escape_rust_char }}) {
                    {% endif %}
                        {% for kase in state.cases %}
                        {% unless kase.is_default %}
                        {% if kase.is_conditional %}
                        _ if {{ kase.condition | rust_expr }} => {
                        {% elsif kase.special_class and kase.chars.size > 0 %}
                        Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                        {% elsif kase.special_class %}
                        Some(b) if Self::is_{{ kase.special_class }}(b) => {
                        {% elsif kase.chars.size == 1 %}
                        Some({{ kase.chars[0] | escape_rust_char }}) => {
                        {% elsif kase.chars.size > 1 %}
                        Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                        {% else %}
                        Some(_) => {
                        {% endif %}
                            {% for cmd in kase.commands %}
                            {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info, states: func.states %}
                            {% endfor %}
                        }
                        {% endunless %}
                        {% endfor %}
                        None => {
                            {% comment %} EOF handling with EXPECTS inference {% endcomment %}
                            {% if return_type_info.kind == "content" %}
                            on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                            {% endif %}
                            {% if func.expects_char %}
                            on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                            {% elsif return_type_info.kind == "bracket" %}
                            on_event(Event::{{ func.return_type }}End { span: self.span() });
                            {% endif %}
                            {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                    {% else %}
                    {% comment %} Non-scannable: check EOF first {% endcomment %}
                    if self.eof() {
                        {% if return_type_info.kind == "content" %}
                        on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                        {% endif %}
                        {% if func.expects_char %}
                        on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                        {% elsif return_type_info.kind == "bracket" %}
                        on_event(Event::{{ func.return_type }}End { span: self.span() });
                        {% endif %}
                        {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
                    }
                    match self.peek() {
                        {% for kase in state.cases %}
                        {% if kase.is_default %}
                        _ => {
                        {% elsif kase.is_conditional %}
                        _ if {{ kase.condition | rust_expr }} => {
                        {% elsif kase.special_class and kase.chars.size > 0 %}
                        Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                        {% elsif kase.special_class %}
                        Some(b) if Self::is_{{ kase.special_class }}(b) => {
                        {% elsif kase.chars.size == 1 %}
                        Some({{ kase.chars[0] | escape_rust_char }}) => {
                        {% elsif kase.chars.size > 1 %}
                        Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                        {% else %}
                        Some(_) => {
                        {% endif %}
                            {% for cmd in kase.commands %}
                            {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info, states: func.states %}
                            {% endfor %}
                        }
                        {% endfor %}
                        {% unless state.has_default %}
                        {% comment %} Add default arm if state has no explicit default case {% endcomment %}
                        _ => {
                            {% if return_type_info.kind == "internal" %}return 0;{% else %}return;{% endif %}
                        }
                        {% endunless %}
                    }
                    {% endif %}
                }
            {% endfor %}
            }
        }
        {% endif %}

        {% comment %} Note: Unreachable code below - returns happen in command handling {% endcomment %}
        {% comment %} This is intentional - the loop above handles all exits {% endcomment %}
    }

{% endfor %}
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_basic() {
        // Basic smoke test - actual tests depend on parser semantics
        let input = b"";
        let mut events = Vec::new();
        Parser::new(input).parse(|e| events.push(e));
        // Events depend on the specific parser
    }
}
