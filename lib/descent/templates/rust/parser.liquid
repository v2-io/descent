//! Generated parser - DO NOT EDIT
//!
//! Generated by descent from {{ parser }}.desc
//!
//! Callback-based recursive descent parser.
//! Call stack = element stack. True recursion handles nesting naturally.

use std::ops::Range;

/// Events emitted by the parser.
#[derive(Debug, Clone, PartialEq)]
pub enum Event<'a> {
{% for type in types %}
{% if type.kind == "bracket" %}
    {{ type.name }}Start { span: Range<usize> },
    {{ type.name }}End { span: Range<usize> },
{% elsif type.kind == "content" %}
    {{ type.name }} { content: &'a [u8], span: Range<usize> },
{% endif %}
{% endfor %}
    Error { code: ParseErrorCode, span: Range<usize> },
}

/// Error codes for parse errors.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ParseErrorCode {
    UnexpectedEof,
    UnexpectedChar,
{% for func in functions %}
{% if func.expects_char %}
    Unclosed{{ func.return_type }},
{% endif %}
{% endfor %}
}

/// Callback-based parser.
///
/// Uses true recursive descent - the call stack IS the element stack.
pub struct Parser<'a> {
    input: &'a [u8],
    pos: usize,
    mark_pos: usize,
    term_pos: usize,
    line: u32,
    column: u32,
}

impl<'a> Parser<'a> {
    /// Create a new parser for the given input.
    pub fn new(input: &'a [u8]) -> Self {
        Self {
            input,
            pos: 0,
            mark_pos: 0,
            term_pos: 0,
            line: 1,
            column: 1,
        }
    }

    /// Parse the input, calling the callback for each event.
    ///
    /// The callback receives events in document order.
    /// For backpressure, have the callback send to a bounded channel.
    pub fn parse<F>(mut self, mut on_event: F)
    where
        F: FnMut(Event<'a>),
    {
        self.parse_{{ entry_point | remove: "/" }}(&mut on_event);
    }

    // ========== Helpers ==========

    #[inline(always)]
    fn peek(&self) -> Option<u8> {
        self.input.get(self.pos).copied()
    }

    #[inline(always)]
    fn eof(&self) -> bool {
        self.pos >= self.input.len()
    }

    #[inline(always)]
    fn advance(&mut self) {
        if self.pos < self.input.len() {
            if self.input[self.pos] == b'\n' {
                self.line += 1;
                self.column = 1;
            } else {
                self.column += 1;
            }
            self.pos += 1;
        }
    }

    #[inline(always)]
    fn mark(&mut self) {
        self.mark_pos = self.pos;
        self.term_pos = self.pos; // Reset term position
    }

    /// Set termination point with optional offset (e.g., -1 for one char before current)
    #[inline(always)]
    fn set_term(&mut self, offset: i32) {
        self.term_pos = (self.pos as i32 + offset) as usize;
    }

    #[inline(always)]
    fn term(&self) -> &'a [u8] {
        // Use term_pos if set after mark, otherwise use current pos
        let end = if self.term_pos > self.mark_pos { self.term_pos } else { self.pos };
        &self.input[self.mark_pos..end]
    }

    #[inline(always)]
    fn span(&self) -> Range<usize> {
        self.pos..self.pos
    }

    #[inline(always)]
    fn span_from_mark(&self) -> Range<usize> {
        self.mark_pos..self.pos
    }

    #[inline(always)]
    fn col(&self) -> i32 {
        self.column as i32
    }

    /// Previous byte (0 at start of input).
    #[inline(always)]
    fn prev(&self) -> u8 {
        if self.pos > 0 {
            self.input[self.pos - 1]
        } else {
            0
        }
    }

    #[inline(always)]
    fn is_letter(b: u8) -> bool {
        b.is_ascii_alphabetic()
    }

    #[inline(always)]
    fn is_label_cont(b: u8) -> bool {
        b.is_ascii_alphanumeric() || b == b'_' || b == b'-'
    }

    // ========== SCAN Methods (SIMD-accelerated via memchr) ==========

    /// Scan forward to find first occurrence of b1, returns matched byte or None for EOF.
    #[inline]
    fn scan_to1(&mut self, b1: u8) -> Option<u8> {
        match memchr::memchr(b1, &self.input[self.pos..]) {
            Some(offset) => {
                // Update line/column for skipped chars
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                // Advance to end
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1 or b2.
    #[inline]
    fn scan_to2(&mut self, b1: u8, b2: u8) -> Option<u8> {
        match memchr::memchr2(b1, b2, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    /// Scan forward to find first occurrence of b1, b2, or b3.
    #[inline]
    fn scan_to3(&mut self, b1: u8, b2: u8, b3: u8) -> Option<u8> {
        match memchr::memchr3(b1, b2, b3, &self.input[self.pos..]) {
            Some(offset) => {
                for &b in &self.input[self.pos..self.pos + offset] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                for &b in &self.input[self.pos..] {
                    if b == b'\n' {
                        self.line += 1;
                        self.column = 1;
                    } else {
                        self.column += 1;
                    }
                }
                self.pos = self.input.len();
                None
            }
        }
    }

    // ========== Generated Parse Functions ==========

{% for func in functions %}
    {% comment %} Determine return type info {% endcomment %}
    {% assign return_type_info = nil %}
    {% for t in types %}
        {% if t.name == func.return_type %}
            {% assign return_type_info = t %}
        {% endif %}
    {% endfor %}

    /// Parse {{ func.name }}{% if func.return_type %} -> {{ func.return_type }}{% endif %}
    {% if func.params.size > 0 %}
    fn parse_{{ func.name }}<F>(&mut self, {% for param in func.params %}{{ param }}: i32, {% endfor %}on_event: &mut F)
    {% else %}
    fn parse_{{ func.name }}<F>(&mut self, on_event: &mut F)
    {% endif %}
    where
        F: FnMut(Event<'a>),
    {
        {% if trace %}eprintln!("TRACE: enter {{ func.name }}");{% endif %}

        {% comment %} BRACKET types: emit Start on entry {% endcomment %}
        {% if return_type_info.kind == "bracket" %}
        let start_span = self.span();
        on_event(Event::{{ func.return_type }}Start { span: start_span.clone() });
        {% endif %}

        {% comment %} CONTENT types: MARK on entry {% endcomment %}
        {% if return_type_info.kind == "content" %}
        self.mark();
        {% endif %}

        {% comment %} Local variables {% endcomment %}
        {% for local in func.locals %}
        let mut {{ local[0] }}: i32 = 0;
        {% endfor %}

        {% comment %} State machine {% endcomment %}
        {% if func.states.size == 1 %}
        {% comment %} Single state - no enum needed {% endcomment %}
        {% assign state = func.states.first %}
        loop {
            {% if state.scannable %}
            {% comment %} SCAN-first optimization {% endcomment %}
            {% assign scan_count = state.scan_chars.size %}
            {% if scan_count == 1 %}
            match self.scan_to1({{ state.scan_chars[0] | escape_rust_char }}) {
            {% elsif scan_count == 2 %}
            match self.scan_to2({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}) {
            {% elsif scan_count == 3 %}
            match self.scan_to3({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}) {
            {% endif %}
                {% for kase in state.cases %}
                {% unless kase.is_default %}
                {% if kase.special_class and kase.chars.size > 0 %}
                {% comment %} Combined: class + literal chars {% endcomment %}
                Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                {% elsif kase.special_class %}
                Some(b) if Self::is_{{ kase.special_class }}(b) => {
                {% elsif kase.chars.size == 1 %}
                Some({{ kase.chars[0] | escape_rust_char }}) => {
                {% else %}
                Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                {% endif %}
                    {% for cmd in kase.commands %}
                    {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info %}
                    {% endfor %}
                }
                {% endunless %}
                {% endfor %}
                None => {
                    {% comment %} EOF handling with EXPECTS inference {% endcomment %}
                    {% if return_type_info.kind == "content" %}
                    on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                    {% endif %}
                    {% if func.expects_char %}
                    on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                    {% elsif return_type_info.kind == "bracket" %}
                    on_event(Event::{{ func.return_type }}End { span: self.span() });
                    {% endif %}
                    return;
                }
                _ => unreachable!("scan_to only returns target chars"),
            }
            {% else %}
            {% comment %} Non-scannable: check EOF first, then match {% endcomment %}
            if self.eof() {
                {% if return_type_info.kind == "content" %}
                on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                {% endif %}
                {% if func.expects_char %}
                on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                {% elsif return_type_info.kind == "bracket" %}
                on_event(Event::{{ func.return_type }}End { span: self.span() });
                {% endif %}
                return;
            }
            match self.peek() {
                {% for kase in state.cases %}
                {% if kase.is_default %}
                _ => {
                {% elsif kase.is_conditional %}
                _ if {{ kase.condition | rust_expr }} => {
                {% elsif kase.special_class and kase.chars.size > 0 %}
                Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                {% elsif kase.special_class %}
                Some(b) if Self::is_{{ kase.special_class }}(b) => {
                {% elsif kase.chars.size == 1 %}
                Some({{ kase.chars[0] | escape_rust_char }}) => {
                {% else %}
                Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                {% endif %}
                    {% for cmd in kase.commands %}
                    {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info %}
                    {% endfor %}
                }
                {% endfor %}
            }
            {% endif %}
        }
        {% else %}
        {% comment %} Multiple states - use enum {% endcomment %}
        #[derive(Clone, Copy)]
        enum State { {% for state in func.states %}{{ state.name | pascalcase }}, {% endfor %} }
        let mut state = State::{{ func.states.first.name | pascalcase }};

        loop {
            match state {
            {% for state in func.states %}
                State::{{ state.name | pascalcase }} => {
                    {% if state.scannable %}
                    {% assign scan_count = state.scan_chars.size %}
                    {% if scan_count == 1 %}
                    match self.scan_to1({{ state.scan_chars[0] | escape_rust_char }}) {
                    {% elsif scan_count == 2 %}
                    match self.scan_to2({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}) {
                    {% elsif scan_count == 3 %}
                    match self.scan_to3({{ state.scan_chars[0] | escape_rust_char }}, {{ state.scan_chars[1] | escape_rust_char }}, {{ state.scan_chars[2] | escape_rust_char }}) {
                    {% endif %}
                        {% for kase in state.cases %}
                        {% unless kase.is_default %}
                        {% if kase.is_conditional %}
                        _ if {{ kase.condition | rust_expr }} => {
                        {% elsif kase.special_class and kase.chars.size > 0 %}
                        Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                        {% elsif kase.special_class %}
                        Some(b) if Self::is_{{ kase.special_class }}(b) => {
                        {% elsif kase.chars.size == 1 %}
                        Some({{ kase.chars[0] | escape_rust_char }}) => {
                        {% else %}
                        Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                        {% endif %}
                            {% for cmd in kase.commands %}
                            {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info, states: func.states %}
                            {% endfor %}
                        }
                        {% endunless %}
                        {% endfor %}
                        None => {
                            {% comment %} EOF handling with EXPECTS inference {% endcomment %}
                            {% if return_type_info.kind == "content" %}
                            on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                            {% endif %}
                            {% if func.expects_char %}
                            on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                            {% elsif return_type_info.kind == "bracket" %}
                            on_event(Event::{{ func.return_type }}End { span: self.span() });
                            {% endif %}
                            return;
                        }
                        _ => unreachable!("scan_to only returns target chars"),
                    }
                    {% else %}
                    {% comment %} Non-scannable: check EOF first {% endcomment %}
                    if self.eof() {
                        {% if return_type_info.kind == "content" %}
                        on_event(Event::{{ func.return_type }} { content: self.term(), span: self.span_from_mark() });
                        {% endif %}
                        {% if func.expects_char %}
                        on_event(Event::Error { code: ParseErrorCode::Unclosed{{ func.return_type }}, span: self.span() });
                        {% elsif return_type_info.kind == "bracket" %}
                        on_event(Event::{{ func.return_type }}End { span: self.span() });
                        {% endif %}
                        return;
                    }
                    match self.peek() {
                        {% for kase in state.cases %}
                        {% if kase.is_default %}
                        _ => {
                        {% elsif kase.is_conditional %}
                        _ if {{ kase.condition | rust_expr }} => {
                        {% elsif kase.special_class and kase.chars.size > 0 %}
                        Some(b) if Self::is_{{ kase.special_class }}(b){% for ch in kase.chars %} || b == {{ ch | escape_rust_char }}{% endfor %} => {
                        {% elsif kase.special_class %}
                        Some(b) if Self::is_{{ kase.special_class }}(b) => {
                        {% elsif kase.chars.size == 1 %}
                        Some({{ kase.chars[0] | escape_rust_char }}) => {
                        {% else %}
                        Some({% for ch in kase.chars %}{{ ch | escape_rust_char }}{% unless forloop.last %} | {% endunless %}{% endfor %}) => {
                        {% endif %}
                            {% for cmd in kase.commands %}
                            {% include 'command' cmd: cmd, func: func, return_type_info: return_type_info, states: func.states %}
                            {% endfor %}
                        }
                        {% endfor %}
                    }
                    {% endif %}
                }
            {% endfor %}
            }
        }
        {% endif %}

        {% comment %} Note: Unreachable code below - returns happen in command handling {% endcomment %}
        {% comment %} This is intentional - the loop above handles all exits {% endcomment %}
    }

{% endfor %}
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_basic() {
        // Basic smoke test - actual tests depend on parser semantics
        let input = b"";
        let mut events = Vec::new();
        Parser::new(input).parse(|e| events.push(e));
        // Events depend on the specific parser
    }
}
