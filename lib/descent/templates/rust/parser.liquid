//! Generated parser - DO NOT EDIT
//!
//! Generated by descent from {{ parser }}.desc
//!
//! This is a placeholder template. The full implementation will include:
//! - Parser struct with streaming state
//! - SIMD-accelerated SCAN methods (memchr)
//! - Callback-based event emission
//! - True recursive descent (call stack = element stack)

use crate::span::Span;
use crate::streaming::{ChunkArena, ChunkSlice, StreamingEvent, ParseErrorCode};

pub struct StreamingParser {
    // Input management
    input: Vec<u8>,
    pos: usize,

    // Position tracking
    line: u32,
    column: u32,
    global_offset: u64,

    // Accumulation
    mark_pos: usize,
}

impl StreamingParser {
    pub fn new() -> Self {
        Self {
            input: Vec::new(),
            pos: 0,
            line: 1,
            column: 1,
            global_offset: 0,
            mark_pos: 0,
        }
    }

    pub fn parse<F>(&mut self, input: &[u8], mut on_event: F)
    where
        F: FnMut(StreamingEvent),
    {
        self.input = input.to_vec();
        self.pos = 0;
        self.parse_{{ entry_point }}(&mut on_event);
    }

    // ========== Helpers ==========

    #[inline(always)]
    fn peek(&self) -> Option<u8> {
        self.input.get(self.pos).copied()
    }

    #[inline(always)]
    fn eof(&self) -> bool {
        self.pos >= self.input.len()
    }

    #[inline(always)]
    fn advance(&mut self) {
        if self.pos < self.input.len() {
            if self.input[self.pos] == b'\n' {
                self.line += 1;
                self.column = 1;
            } else {
                self.column += 1;
            }
            self.pos += 1;
            self.global_offset += 1;
        }
    }

    #[inline]
    fn mark(&mut self) {
        self.mark_pos = self.pos;
    }

    #[inline]
    fn term(&self) -> &[u8] {
        &self.input[self.mark_pos..self.pos]
    }

    fn span_from_mark(&self) -> Span {
        Span::new(self.mark_pos, self.pos)
    }

    // ========== SCAN Methods ==========

    #[inline]
    fn scan_to1(&mut self, b1: u8) -> Option<u8> {
        match memchr::memchr(b1, &self.input[self.pos..]) {
            Some(offset) => {
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                self.pos = self.input.len();
                None
            }
        }
    }

    #[inline]
    fn scan_to2(&mut self, b1: u8, b2: u8) -> Option<u8> {
        match memchr::memchr2(b1, b2, &self.input[self.pos..]) {
            Some(offset) => {
                self.pos += offset;
                Some(self.input[self.pos])
            }
            None => {
                self.pos = self.input.len();
                None
            }
        }
    }

    // ========== Generated Functions ==========

{% for func in functions %}
    fn parse_{{ func.name }}<F>(&mut self, on_event: &mut F)
    where
        F: FnMut(StreamingEvent),
    {
        // TODO: Generate from IR
        // States: {{ func.states | map: "name" | join: ", " }}
        // Params: {{ func.params | join: ", " }}
        // Locals: {{ func.locals | keys | join: ", " }}
    }

{% endfor %}
}

// Placeholder - actual implementation will be generated from IR
